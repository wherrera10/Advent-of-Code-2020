#=
The weather routing problem has the following parts:

a predicted surface wind direction and speed, at increments of longitude, latitude, and time
an expected surface current direction and speed, at increments of longitude, latitude, and time
'polar data' describing maximum speed of a sailboat at points of sail for a given speed of wind over water
regions for sailing (the open ocean) and not (the land, shallows, restricted areas, etc.)
a starting location and time, and a destination
Given the above information and a specific path, progress and arrival time are determined.
The weather routing problem, conversely, is to determine the path which results in the earliest arrival time.
=#

using CoordinateTransformations, DelimitedFiles, GeographicLib, JuMP

const sealevelradius = 6370000  # meters
const filename = "polar.csv"
const winds, degrees, speeds = getpolardata(filename)

deg2rad(deg) = (deg * π / 180.0 + 2π) % 2π 
rad2deg(rad) = (rad * (180.0 / π) + 360.0) % 360.0

knots2meterspersecond(knots) = knots * 0.514444444
meterpersecond2knots(mps) =  mps * 1.94384449

function haversine_bearing(lat1, lon1, lat2, lon2)
    azi, baz, dist, angle = GeographicLib.inverse(lon1, lat1, lon2, lat2)
    return dist, angle
end

function inverse_haversine(lat1, lon1, distance, direction)
    lon, lat, baz, dist, angle = GeographicLib.forward(WGS84, lon1, lat1, direction, distance)
    return lat, lon
end

struct SailingParameters
    winddeg::Float32
    windkts::Float32
    currentdeg::Float32
    currentkts::Float32
end

function sailingparameters(seatime, longitude, latitude)

end

function getpolardata(filename)
    datacells, headercells = readdlm(filename, ';', header=true)
    winds = map(x -> parse(Float32, x), headercells[2:end])
    degrees = datacells[:, 1]
    speeds = datacells[:, 2:end]
    return winds, degrees, speeds  # speeds indexed by [wind degrees, windspeed knots]
end



function bestboatspeed(pointofsail, windspeed)
    udeg = findlast(t -> t <= pointofsail, degrees)
    odeg = findfirst(t -> t >= pointofsail, degrees)
    uvel = findlast(t -> t <= windspeed, winds)
    ovel = findfirst(t -> t >= windspeed, winds)
    if any(t -> t == nothing, [udeg, odeg, uvel, ovel])
        return -1.0
    end
    frac = (odeg == udeg && uvel == ovel) ? 1.0 :
            (odeg == udeg) ? (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel]) :
            (uvel == ovel) ? (pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) :
            ((pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) +
            (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel])) / 2
    return speeds[udeg, uvel] + frac * (speeds[odeg, ovel] - speeds[udeg, uvel])
end

function relativeboatspeed(destdirection, pointofsail, windspeed)
    VMG = bestboatspeed(pointofsail, windspeed)
    return read2deg(VMG * cos(abs(pointofsail - windspeed)))
end

function boatvector(dirtravel, dirwind, windspeed, dircur, velcur)
    pointofsail = (dirtravel - dirwind) % 360.0
    pointofsail = pointofsail < 0 ? pointofsail + 360.0 : pointofsail
    pointofsail = if pointofsail > 180.0 ? 360.0 - pointofsail : pointofsail
    VMG = bestboatspeed(pointofsail, windspeed)
    other, idx = findmax([relativeboatspeed(pointofsail, x, windspeed) for x in degrees])
    if other > VMG
        pointofsail = degrees[idx]
        VMG = other
    end
    dirchosen = deg2rad(dirwind + pointofsail)
    wx, wy = VMG * sin(dirchosen), VMG * cos(dirchosen)
    curx, cury = velcur * sin(deg2rad(dircur)), velcur * cos(deg2rad(dircur))
    return rad2deg(atan(wy + cury, wx + curx)), sqrt((wx + curx)^2 + (wy + cury)^2)
end

function sailsegment(seatime, duration, curlong, curlat, destlong, destlat)
    distance, dir = haversine_bearing(curlong, curlat, destlong, destlat)
    p = sailingparameters(seatime, curlong, curlat)
    dir2, distance = boatvector(dir, p.winddeg, p.windkts, p.currentdeg, p.currentkts)
    lon2, lat2 = inverse_haversine(lat1, lon1, distance, dir2)
end


@show bestboatspeed(90, 19.0)
@show bestboatspeed(95, 19.0)
@show bestboatspeed(100, 19.0)

