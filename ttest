const files = ["top1", "des1", "ip1", "ip2", "top2", "ip3", "extra1", "ip1a", "ipcommon",
    "ip2a", "ip2b", "ip2c", "des1a", "des1b", "des1c", "des1a1", "des1a2", "des1c1"]

const numfile = Dict(files[i] => i for i in 1:length(files))

const dep = Dict(
    "top1" => ["des1", "ip1", "ip2"],
    "top2" => ["des1", "ip2", "ip3"],
    "ip1" => ["extra1", "ip1a", "ipcommon"],
    "ip2" => ["ip2a", "ip2b", "ip2c", "ipcommon"],
    "des1" => ["des1a", "des1b", "des1c"],
    "des1a" => ["des1a1", "des1a2"],
    "des1c" => ["des1c1", "extra1"])

isdep(f1, f2) = (haskey(dep, f1) && (f2 in dep[f1] || any(x -> isdep(x, f2), dep[f1])))

istoplevel(file) = haskey(dep, file) && !any(x -> file in x, values(dep))

function compileorder(allfiles, deps)
    files, depens = deepcopy(allfiles), deepcopy(deps)
    levels = Vector{Vector{String}}()
    while true
        basefiles = filter(x -> !haskey(depens, x), files)
        if isempty(basefiles)
            break
        end
        push!(levels, basefiles)
        files = filter(x -> haskey(depens, x), files)
        for (k, v) in depens, file in basefiles
            if file in v
                depens[k] = filter(x -> x != file, depens[k])
            end
        end
        for k in keys(depens)
            if isempty(depens[k])
                delete!(depens, k)
            end
        end
    end
    levels
end

dependencyordered = compileorder(files, dep)

function alldeps(file)
    ret = [file]
    if haskey(dep, file)
        deps = dep[file]
        append!(ret, deps)
        for f in deps
            append!(ret, alldeps(f))
        end
    end
    return unique(ret)
end

function compileplan(file)
    files = alldeps(file)
    for (i, level) in enumerate(dependencyordered)
        lfiles = filter(x -> x in level, files)
        println("Step $i: compile $lfiles")
    end
end
    

println("The toplevels are: ", filter(istoplevel, files))

println("Compile order for top1: ", compileplan("top1"))
println("Compile order for top2: ", compileplan("top2"))

#=
The task is to create a program that given a graph of the dependency:

Determines the top levels from the dependencies and show them.
Extracts a compile order of files to compile any given (usually top level) file.
Give a compile order for file top1.
Give a compile order for file top2.
You may show how to compile multiple top levels as a stretch goal
=#
