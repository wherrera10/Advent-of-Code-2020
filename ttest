import Base.print, Base.sort!

abstract type Entry end

mutable struct OutlineEntry <: Entry
    level::Int
    text::String
    parent::Union{Entry, Nothing}
    children::Vector{Entry}
end

mutable struct Outline
    root::OutlineEntry
    entries::Vector{OutlineEntry}
    baseindent::String
end

rootentry() = OutlineEntry(0, "", nothing, [])
indentchar(ch) = ch == ' ' || ch == '\t'
firsttext(s) = something(findfirst(!indentchar, s), length(s) + 1)
splitline(s) = begin i = firsttext(s); i == 1 ? ("", s) : (s[1:i-1], s[i:end]) end

const _indents = ["        "]

function Base.print(io::IO, oe::OutlineEntry)
    println(io, _indents[end]^oe.level, oe.text)
    for child in oe.children
        print(io, child)
    end
end

function Base.print(io::IO, o::Outline)
    push!(_indents, o.baseindent)
    print(io, o.root)
    pop!(_indents)
end

function firstindent(lines, default = "        ")
    for lin in lines
        s1, s2 = splitline(lin)
        s1 != "" && return s1
    end
    return default
end

function Outline(str::String)
    arr, lines = OutlineEntry[], filter(x -> x != "", split(str, r"\r\n|\n|\r"))
    root, indent, parentindex, lastindents = rootentry(), firstindent(lines), 0, 0
    indentlen, indentregex = length(indent), Regex(indent)
    for (i, lin) in enumerate(lines)
        header, txt = splitline(lin)
        indentcount = length(collect(eachmatch(indentregex, header)))
        (indentcount * indentlen < length(header)) && throw("Error: bad indent <$header>")
        if indentcount > lastindents
            parentindex = i > 1 ? i - 1 : 0
        elseif indentcount < lastindents
            parentindex = something(findlast(x -> x.level == indentcount, arr), 0)
        end
        lastindents = indentcount
        ent = OutlineEntry(indentcount, txt, parentindex == 0 ? root : arr[parentindex], [])
        push!(ent.parent.children, ent)
        push!(arr, ent)
    end
    return Outline(root, arr, indent)
end

function sorttree!(ent::OutlineEntry, rev=false)
print(ent.children, " --> ")
    for child in ent.children
        sorttree!(child, rev)
    end
    sort!(ent.children, lt=(x, y) -> x.text < y.text, rev=rev)
println(ent.children)
    return ent
end

sort!(o::Outline, rev=false) = begin sorttree!(o.root, rev); o end

outl = Outline("""
This topic is topical
    C.
        3.
        1.
        2.
        4.
    B.
        2.
        4.
        3.
        1.
    A.
Second, another topic
    C.
    A.
    B.
Done""")

println(outl)
println(sort!(outl))
println(sort!(outl, true))
println(sort!(outl))
