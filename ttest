import Main.≈

const radius = 1.0   # simplifies calculations
const θ = π / 6      # 30 degrees

struct Point
    x::Float32
    y::Float32
end

Main.:≈(p1::Point, p2::Point) = ≈(p1.x, p2.x, atol= 0.00001) && ≈(p1.y, p2.y, atol=0.00001)

rightwardfrom(start, angle) = Point(start.x + sin(angle + θ), start.y + cos(angle + θ))
leftwardfrom(start, angle) = Point(start.x + sin(angle - θ), start.y + cos(angle - θ))

struct RailwayCircuit
    startpoint::Point
    startdirection::Float64
    turns::Array{Int, 1}  # 1 for right, -1 for left
    RailwayCircuit(turnarray=Bool[]) = new(Point(0, 0), 0, turnarray)
end

function issymmetry(c1, c2)
    return length(c1) == length(c2) && sum(c1) == sum(c2) &&
        any(n -> c1 == circshift(c2, n), 0:length(c2)-1)
end

isduplicate(c1, c2) = issymmetry(c1, c2) || issymmetry(c1, [-x for x in c2])

function points(tracks::RailwayCircuit)
    ret, point, ϕ = [tracks.startpoint], tracks.startpoint, tracks.startdirection
    for turn in tracks.turns
        if turn ==  1
            point = rightwardfrom(point, ϕ)
            ϕ = (ϕ + θ) % 2π
        else
            lastangle = ϕ
            point = leftwardfrom(point, ϕ)
             ϕ = (ϕ - θ) % 2π
        end
        push!(ret, point)
    end
    return ret, ϕ - tracks.startdirection
end

function isvalidcircuit(tracks, useangle=true)
    if sum(tracks.turns) % 12  != 0
        return false
    end
    c, ϕ = points(tracks)
    return c[1] ≈ c[end] && (!useangle || isapprox(0.0, ϕ, atol=0.00001))
end

function allvalidcircuits(N)
    ret = RailwayCircuit[]
    for i in 0:2^N-1
        c = RailwayCircuit([d == 0 ? -1 : 1 for d in digits(i, base=2, pad=N)])
        if isvalidcircuit(c) & all(x -> !isduplicate(x.turns, c.turns), ret)
            push!(ret, c)
        end
    end
    ret
end

for i in 12:4:48
    println("\nFor N of $i:")
    for r in allvalidcircuits(i)
        println(r.turns)
    end
end
