import Main.≈

const radius = 1.0   # simplifies calculations
const θ = π / 6      # 30 degrees

struct Point
    x::Float32
    y::Float32
end

Main.:≈(p1::Point, p2::Point) = ≈(p1.x, p2.x, atol= 0.00001) && ≈(p1.y, p2.y, atol=0.00001)

rightwardfrom(start, angle) = Point(start.x + sin(angle + θ), start.y + cos(angle + θ))
leftwardfrom(start, angle) = Point(start.x + sin(angle - θ), start.y + cos(angle - θ))

allshifts(c) = [circshift(c, i) for i in 0:length(c)-1]
canonical(c) = maximum(vcat(allshifts(c), allshifts([-x for x in c])))

function points(turns)
    ret, point, ϕ = [Point(0,0)], Point(0,0), 0.0
    for turn in turns
        if turn == 1
            point = rightwardfrom(point, ϕ)
            ϕ += θ
        else
            point = leftwardfrom(point, ϕ)
             ϕ -= θ
        end
        push!(ret, point)
    end
    return ret
end

valid(turns) = sum(turns) % 12 != 0 ? false : (c = points(turns); c[1] ≈ c[end])

function allvalidcircuits(N, doprint)
    found = Vector{Vector{Int}}()
    println("\nFor N of $N: ")
    for i in 0:2^N-1
        turns = [d == 0 ? -1 : 1 for d in digits(i, base=2, pad=N)]
        if valid(turns)
            canon = canonical(turns)
            if !(canon in found)
                doprint && println(canon)
                push!(found, canon)
            end
        end
    end
    println("There are ", length(found), " unique valid circuits.")
end

for i in 12:4:32
    allvalidcircuits(i, i < 20)
end

