using Gtk
import Base.==

const whitepawn = UInt8('w')
const blackpawn = UInt8('b')
ispawn(c) = (c == whitepawn || c == blackpawn)
oppositepawn(c1, c2) = ispawn(c1) && ispawn(c2) && c1 != c2
pawndirection(c) = (c == whitepawn) ? +1 : -1
const unipawns = Dict(" " => " ", "w" => "\u2659", "b" => "\u265f", "\u2659" => "w", "\u265f" => "b")

mutable struct HState
    board::Matrix{UInt8}
    whitetomove::Bool
    HState(arr, iswhite) = new(reshape(UInt8.(arr), 3, 3), iswhite)
end

==(h1::HState, h2::HState) = h1.board == h2.board && h1.whitetomove == h2.whitetomove

const positionmoves = Dict{HState,Vector{Int}}(
    # white is computer, moves middle first
    HState(b"w w b  bb", true) => [1, 1, 1, 2], HState(b"w w b bb ", true) => [1, 3, 2, 3],
    HState(b"w   bbb  ", true) => [1, 1, 2, 2], HState(b"  wbb   b", true) => [1, 3, 2, 2],
    HState(b"w  bbw b ", true) => [2, 3, 3, 3],
    # white is computer, moves left first
    HState(b" wwb  b b", true) => [1, 2, 2, 2], HState(b"  wbb   b", true) => [1, 3, 2, 2],
    HState(b"  wbb b  ", true) => [1, 3, 2, 2],
    # white is computer, moves right first
    HState(b"ww   bb b", true) => [1, 2, 2, 2], HState(b"w   b   b", true) => [1, 1, 2, 2],
    HState(b"w    bb  ", true) => [1, 1, 1, 2],
    # black is computer
    HState(b" www  bbb", false) => [3, 2, 2, 1], HState(b"ww   wbbb", false) => [3, 2, 2, 3],
    HState(b"w w w bbb", false) => [3, 1, 2, 2],
    HState(b"  ww  b b", false) => [3, 3, 2, 3], HState(b"w   w  bb", false) => [3, 3, 2, 3])

function legalmoves(board, px, py)
    moves = Vector{Pair{Int, Int}}()
    c = board[py, px]
    newrow = px + pawndirection(c)
    if ispawn(c) && 0 < newrow < 4
        if py > 1 && oppositepawn(c, board[py - 1, newrow])
            push!(moves, Pair(newrow, py - 1))
        end
        if board[py, newrow] == UInt8(' ')
            push!(moves, Pair(newrow, py))
        end
        if py < 3 && oppositepawn(c, board[py + 1, newrow])
            push!(moves, Pair(newrow, py + 1))
        end
    end
    moves
end

islegalmove(board, px, py, i, j) = Pair(i, j) in legalmoves(board, px, py)

function allavailablemoves(board, forwhite)
    allret = Vector{Pair{Vector{Int}, Vector{Pair{Int, Int}}}}()
    for i in 1:3, j in 1:3
        if (board[i, j] == whitepawn && forwhite) || (board[i, j] == blackpawn && !forwhite)
            push!(allret, [i, j] => legalmoves(board, i, j))
        end
    end
    allret
end

function checkforwin(hstate)
    x = (any(x -> hstate.board[x] == whitepawn, 7:9) ? whitepawn :
        any(x -> hstate.board[x] == blackpawn, 1:3) ? blackpawn : ' ')
    return (x != ' ') ? x :
        isempty(allavailablemoves(hstate.board, hstate.whitetomove)) ?
        (hstate.whitetomove ? blackpawn : whitepawn) : UInt8(' ')
end

function hexapawnapp()
    win = GtkWindow("Hexapawn Game", 425, 425) |> (GtkFrame() |> (box = GtkBox(:v)))
    toolbar = GtkToolbar()
    newWgame = GtkToolButton("New Game, Play as White")
    set_gtk_property!(newWgame, :label, "New Game, Play as White")
    set_gtk_property!(newWgame, :is_important, true)
    newBgame = GtkToolButton("New Game, Play as Bloack")
    set_gtk_property!(newBgame, :label, "New Game, Play as Black")
    set_gtk_property!(newBgame, :is_important, true)
    map(w->push!(toolbar,w),[newWgame, newBgame])
    scrwin = GtkScrolledWindow()
    grid = GtkGrid()
    map(w -> push!(box, w),[toolbar, scrwin])
    push!(scrwin, grid)
    buttons = Array{Gtk.GtkButtonLeaf, 2}(undef, 3, 3)
    stylist = GtkStyleProvider(Gtk.CssProviderLeaf(data="button {font-size:64px;}"))
    for i in 1:3, j in 1:3
        grid[i, 4-j] = buttons[i, j] = GtkButton()
        set_gtk_property!(buttons[i, j], :expand, true)
        push!(Gtk.GAccessor.style_context(buttons[i, j]), stylist, 600)
    end

    state = HState(b"www   bbb", true)
    won = ""
    pwhite = true
    ptomove = false
    ctomove = false
    pselected = false
    xsel, ysel = 0, 0

    function update!()
        for i in 1:3, j in 1:3
            set_gtk_property!(buttons[i, j], :label, unipawns["$(Char(state.board[i, j]))"])
        end
        if (w = checkforwin(state)) != UInt8(' ')
            won = (w == whitepawn) ? "White Has Won" : "Black Has Won"
            ptomove, ctomove = false, false
        else
            won = ""
        end
        set_gtk_property!(win, :title, "$won Hexapawn Game")
    end

    function initialize!()
        state = HState(b"www   bbb", true)
        update!()
    end

    function newgame!(p)
        initialize!()
        if p == whitepawn
            pwhite = true
            ptomove, ctomove = true, false
        else
            pwhite = false
            ptomove, ctomove = false, true
        end
    end

    function domove!(board, m)
        board[m[4], m[3]], board[m[2], m[1]] = board[m[2], m[1]], UInt8(' ')
        update!()
    end

    function findrowcol(button)
        for i in 1:3, j in 1:3
            if buttons[i, j] == button
                return i, j
            end
        end
        return 0, 0
    end

    function playerclicked(button)
        update!()
        if won == "" && ptomove
            j, i = findrowcol(button)
            if !pselected && i > 0 &&
                state.board[j, i] == (pwhite ? whitepawn : blackpawn)
                xsel, ysel = i, j
                pselected = true
            elseif pselected
                if islegalmove(state.board, xsel, ysel, i, j)
                    domove!(state.board, [xsel, ysel, i, j])
                    xsel, ysel = 0, 0
                    pselected = false
                    ptomove = false
                    ctomove = true
                    state.whitetomove = false
                else
                    pselected = false
                    xsel, ysel = 0, 0
                end
            end
        end
        update!()
    end

    function computerplay!()
        while true
            if won == "" && ctomove
                cmove = [0, 0, 0, 0]
                update!()
    println(state)
      println("cplay: got here ", haskey(positionmoves, state))
      println(positionmoves)
                if state == HState(b"www   bbb", true)  # starting
                    cmove = rand([[1, 1, 2, 1], [1, 2, 2, 2], [1, 3, 2, 3]])
                elseif haskey(positionmoves, state)
    println("state found: move is found")
                    cmove = positionmoves[state]
                else
                    for p in allavailablemoves(state.board, state.whitetomove), m in p[2]
                        b = deepcopy(state.board)
                        i1, j1, i2, j2 = p[1][1], p[1][2], m[1], m[2]
                        b[i1, j1], b[i2, j2] = b[i2, j2], b[i1, j1]
                        newstate = HexapawnState(b, !state.whitetomove)
                        x = checkforwin(newstate)
                        if x != ' ' # move wins
                            cmove = [i1, j1, i2, j2]
                        end
                    end
                end
                if cmove[1] == 0
                    throw("No known move for position $hstate")
                else
                    domove!(state.board, cmove)
                    ptomove, ctomove = true, false
                    state.whitetomove = true
                end
            else
            end
            yield()
            sleep(0.4)
        end
    end

    for i in 1:3, j in 1:3
        signal_connect(playerclicked, buttons[i, j], "clicked")
    end
    newplayerwhitegame!(w) = newgame!(whitepawn)
    newplayerblackgame!(w) = newgame!(blackpawn)
    signal_connect(newplayerwhitegame!, newWgame, :clicked)
    signal_connect(newplayerblackgame!, newBgame, :clicked)
    newplayerwhitegame!(win)
    condition = Condition()
    endit(w) = notify(condition)
    signal_connect(endit, win, :destroy)
    showall(win)
    @async computerplay!()
    wait(condition)
end

hexapawnapp()
