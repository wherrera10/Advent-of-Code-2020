abstract type Entry end

mutable struct OutlineEntry
    level::Int
    text::String
    parent::Union{Entry, Nothing}
    children::Vector{Entry}
end

rootentry() = OutlineEntry(0, "", Nothing, [])

mutable struct Outline
    root::OutlineEntry
    entries::Vector{OutlineEntry}
    baseindent::String
end

indentchar(ch) = ch == ' ' || ch == '\t'
firstnonindent(lin) = something(findfirst(!indentchar, lin), length(lin) + 1)

function splitline(lin)
    i = firstnonindent(lin)
    return i == 1 ? ("", lin) : (lin[1:i-1], lin[i:end])
end

function firstindent(lines, default = "        ")
    for lin in lines
        s1, s2 = splitline(lin)
        s != "" && return s1
    end
    return default
end

function Outline(str::String)
    entries, lines = OutlineEntry[], filter(x -> x != "", split(text, r"\r\n|\n|\r"))
    root, indent, parentindex, lastindents = rootentry(), firstindent(lines), 0, 0
    indentlen, indentregex = length(indent), Regex(indent)
    for (i, lin) in enumerate(lines)
        header, txt = splitline(lin)
        indentcount = length(collect(eachmatch(indentregex, header)))
        (indentcount * indentlen < length(header)) && throw("Error: bad indent <$header>")
        if indentcount > lastindents
            parentindex = i > 1 ? i - 1 : 0
        elseif indentcount < lastindents
            parentindex = something(findlast(x -> x.level == indexcount, entries), 0)
        end
        lastindents = indentcount
        ent = OutlineEntry(indentcount, txt, parentindex == 0 ? root : 
            entries[parentindex], Entry[])
        push!(ent.parent.children, ent)
        push!(entries, ent)
    end
    return Outline(root, entries, indent)
end

function sorttree!(ent::OutlineEntry, rev=false)
    sort!(ent.children, lt=(x, y) -> x.text < y.text, rev=rev)
    for child in ent.children
        sorttree!(child, rev)
    end
    return ent
end

sorted(o::Outline, r=false) = (x = deepcopy(o); for e in x.entries sorttree!(e, r); end; x)



