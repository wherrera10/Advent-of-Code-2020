
Uses the LightGraphs package.

 
using LightGraphs
 
const grid = reshape(Vector{UInt8}(replace("""
         00000         
      00003130000      
    000321322221000    
   00231222432132200   
  0041433223233211100  
  0232231612142618530  
 003152122326114121200 
 031252235216111132210 
 022211246332311115210 
00113232262121317213200
03152118212313211411110
03231234121132221411410
03513213411311414112320
00427534125412213211400
 013322444412122123210 
 015132331312411123120 
 003333612214233913300 
  0219126511415312570  
  0021321524341325100  
   00211415413523200   
    000122111322000    
      00001120000      
         00000         """, "\n" => "")), 23, 23)
 
const board = map(c -> c == UInt8(' ') ? -1 : c - UInt8('0'), grid)
const startingpoints = [i for i in 1:529 if board[i] > 0]
const safety = [i for i in 1:529 if board[i] == 0]
const legalendpoints = [i for i in 1:529 if board[i] >= 0]
 
function adjacent(i)
    k, ret = board[i], Int[]
    row, col = divrem(i - 1, 23) .+ 1
    col > k && push!(ret, i - k)
    23 - col >= k && push!(ret, i + k)
    row > k && push!(ret, i - 23 * k)
    row + k <= 23 && push!(ret, i + 23 * k)
    row > k && col > k && push!(ret, i - 24 * k)
    row + k <= 23 && (23 - col >= k) && push!(ret, i + 24 * k)
    row > k && (23 - col >= k) && push!(ret, i - 22 * k)
    row + k <= 23 && col > k && push!(ret, i + 22 * k)
    ret
end
 
const graph = SimpleDiGraph(529)
 
for i in 1:529
    if board[i] > 0
        for p in adjacent(i)
            if board[p] >= 0
                add_edge!(graph, i, p)
            end
        end
    end
end
 
"""
    allnpaths(graph, a, b, vec, n)
 
Return a vector of int vectors, each of which is a path from a to a member of
vec and where n is the length of each path and the nodes in a path do not repeat.
"""
function allnpaths(graph, a, vec, n)
    ret = [[a]]
    for j in 2:n
        nextret = Vector{Vector{Int}}()
        for path in ret, x in neighbors(graph, path[end])
            if !(x in path) && (j < n || x in vec)
                push!(nextret, [path; x])
            end
        end
        ret = nextret
    end
    return (ret == [[a]] && a != b) ? [] : ret
end
 
function pathtostring(path)
    ret = ""
    for node in path
        c = CartesianIndices(board)[node]
        ret *= "($(c[2]-1), $(c[1]-1)) "
    end
    ret
end
 
function pathlisting(paths)
    join([pathtostring(p) for p in paths], "\n")
end
 
println("Part 1:")
let
    start = 23 * 11 + 12
    pathsfromcenter = dijkstra_shortest_paths(graph, start)
    safepaths = filter(p -> length(p) > 1, enumerate_paths(pathsfromcenter, safety))
    safelen = mapreduce(length, min, safepaths)
    paths = unique(allnpaths(graph, start, safety, safelen))
    println("The $(length(paths)) shortest paths to safety are:\n",
        pathlisting(paths))
end
 
println("\nPart 2:")
let
    p = enumerate_paths(bellman_ford_shortest_paths(graph, 21 * 23 + 12), 23 + 12)
    println("One shortest route from (21, 11) to (1, 11): ", pathtostring(p))
 
    p = enumerate_paths(bellman_ford_shortest_paths(graph, 23 + 12), 21 * 23 + 12)
    println("\nOne shortest route from (1, 11) to (21, 11): ", pathtostring(p))
 
    allshortpaths = [enumerate_paths(bellman_ford_shortest_paths(graph, 23 + 12), p) for p in startingpoints]
    maxlen, idx = findmax(map(length, allshortpaths))
    println("\nLongest Shortest Route (length $(maxlen - 1)) is: ", pathtostring(allshortpaths[idx]))
end
 
println("\nExtra Credit Questions:")
let
    println("\nIs there any cell in the country that can not be reached from HQ (11, 11)?")
    frombase = bellman_ford_shortest_paths(graph, 11 * 23 + 12)
    unreached = Int[]
    for pt in legalendpoints
        path = enumerate_paths(frombase, pt)
        if isempty(path) && pt != 11 * 23 + 12
            push!(unreached, pt)
        end
    end
    print("There are $(length(unreached)): ")
    println(pathtostring(unreached))
 
    println("\nWhich cells will it take longest to send reinforcements to from HQ (11, 11)?")
    p = [enumerate_paths(frombase, x) for x in legalendpoints]
    maxlen = mapreduce(length, max, p)
    allmax = [path for path in p if length(path) == maxlen]
    println("There are $(length(allmax)) of length $(maxlen - 1):")
    println(pathlisting(allmax))
end
 

#=
The weather routing problem has the following parts:

a predicted surface wind direction and speed, at increments of longitude, latitude, and time
an expected surface current direction and speed, at increments of longitude, latitude, and time
'polar data' describing maximum speed of a sailboat at points of sail for a given speed of wind over water
regions for sailing (the open ocean) and not (the land, shallows, restricted areas, etc.)
a starting location and time, and a destination
Given the above information and a specific path, progress and arrival time are determined.
The weather routing problem, conversely, is to determine the path which results in the earliest arrival time.
=#

using DelimitedFiles, JuMP

function getpolardata(filename)
    datacells, headercells = readdlm(filename, ';', header=true)
    winds = map(x -> parse(Float32, x), headercells[2:end])
    degrees = datacells[:, 1]
    speeds = datacells[:, 2:end]
    return winds, degrees, speeds  # speeds indexed by [wind degrees, windspeed knots]
end

const R = 6372800  # earth approximate radius in meters
const filename = "polar.csv"
const winds, degrees, speeds = getpolardata(filename)

deg2rad(deg) = (deg * π / 180.0 + 2π) % 2π 
rad2deg(rad) = (rad * (180.0 / π) + 360.0) % 360.0
cartesian2polar(x, y) = sqrt(x * x + y * y), atand(x, y)
polar2cartesian(r, deg) = r .* sincosd(deg)

function haversine(lon1, lat1, lon2, lat2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sind(dlat / 2)^2 + cosd(lat1) * cosd(lat2) * sind(dlon / 2)^2
    c = 2.0 * asind(sqrt(a))
    theta = atand(sind(dlon) * cosd(lat2), 
        cosd(lat1) * sind(lat2) - sind(lat1) * cosd(lat2) * cosd(dlon))
    theta = (theta + 360) % 360
    return R * c * 0.5399565, theta
end

function inverse_haversine(lon1, lat2, distance, direction)
    lat2 = asind(sind(lat1) * cos(distance / R) + cosd(lat1) * sin(d / R) * cosd(direction)
    lon2 = lon1 + atand(sind(direction) * sin(distance / R) * cosd(lat1), 
                       cos(distance / R) - sind(lat1) * sind(lat2))
    return lon2, lat2
end

knots2meterspersecond(knots) = knots * 0.514444444
meterpersecond2knots(mps) =  mps * 1.94384449

struct SailingParameters
    winddeg::Float32
    windkts::Float32
    currentdeg::Float32
    currentkts::Float32
end

function sailingparameters(seatime, longitude, latitude)

end

function bestboatspeed(pointofsail, windspeed)
    udeg = findlast(t -> t <= pointofsail, degrees)
    odeg = findfirst(t -> t >= pointofsail, degrees)
    uvel = findlast(t -> t <= windspeed, winds)
    ovel = findfirst(t -> t >= windspeed, winds)
    if any(t -> t == nothing, [udeg, odeg, uvel, ovel])
        return -1.0
    end
    frac = (odeg == udeg && uvel == ovel) ? 1.0 :
            (odeg == udeg) ? (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel]) :
            (uvel == ovel) ? (pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) :
            ((pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) +
            (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel])) / 2
    return speeds[udeg, uvel] + frac * (speeds[odeg, ovel] - speeds[udeg, uvel])
end

sailingspeed(azimuth, dir, ws) = bestboatspeed(dir, ws) * cosd(abs(dir - azimuth))

function boatvector(dirtravel, dirwind, windspeed, dircur, velcur)
    pointofsail = (dirtravel - dirwind) % 360.0
    pointofsail = pointofsail < 0 ? pointofsail + 360.0 : pointofsail
    pointofsail = if pointofsail > 180.0 ? 360.0 - pointofsail : pointofsail
    VMG = bestboatspeed(pointofsail, windspeed)
    other, idx = findmax([sailingspeed(pointofsail, x, windspeed) for x in degrees])
    if other > VMG
        pointofsail = degrees[idx]
        VMG = other
    end
    dirchosen = deg2rad(dirwind + pointofsail)
    wx, wy = VMG * sin(dirchosen), VMG * cos(dirchosen)
    curx, cury = velcur * sin(deg2rad(dircur)), velcur * cos(deg2rad(dircur))
    return rad2deg(atan(wy + cury, wx + curx)), sqrt((wx + curx)^2 + (wy + cury)^2)
end

function sailsegment(seatime, duration, curlong, curlat, destlong, destlat)
    dir = haversine(curlong, curlat, destlong, destlat)[2]
    p = sailingparameters(seatime, curlong, curlat)
    dir2, distance = boatvector(dir, p.winddeg, p.windkts, p.currentdeg, p.currentkts)
    lon2, lat2 = inverse_haversine(lon1, lat1, distance, dir2)
end


@show bestboatspeed(90, 19.0)
@show bestboatspeed(95, 19.0)
@show bestboatspeed(100, 19.0)


