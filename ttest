#=
The weather routing problem has the following parts:

a predicted surface wind direction and speed, at increments of longitude, latitude, and time
an expected surface current direction and speed, at increments of longitude, latitude, and time
'polar data' describing maximum speed of a sailboat at points of sail for a given speed of wind over water
regions for sailing (the open ocean) and not (the land, shallows, restricted areas, etc.)
a starting location and time, and a destination
Given the above information and a specific path, progress and arrival time are determined.
The weather routing problem, conversely, is to determine the path which results in the earliest arrival time.
=#

module SailingPolars

using DelimitedFiles

export SailingPolar, SurfaceParameters, getpolardata
export boatspeed, bestvectorspeed, sailsegmenttime

struct SailingPolar
    winds::Vector{Float32}
    degrees::Vector{Float32}
    speeds::Matrix{Float32} # speeds[wind direction degrees, windspeed knots]
end

struct SurfaceParameters
    winddeg::Float32
    windkts::Float32
    currentdeg::Float32
    currentkts::Float32
end

function getpolardata(filename)
    datacells, headercells = readdlm(filename, ';', header=true)
    winds = map(x -> parse(Float32, x), headercells[2:end])
    degrees = datacells[:, 1]
    speeds = datacells[:, 2:end]
    return SailingPolar(winds, degrees, speeds)
end

const R = 6372800  # earth approximate radius in meters
deg2rad(deg) = (deg * π / 180.0 + 2π) % 2π
rad2deg(rad) = (rad * (180.0 / π) + 360.0) % 360.0
cartesian2polar(x, y) = sqrt(x * x + y * y), atand(x, y)
polar2cartesian(r, deg) = r .* sincosd(deg)

function haversine(lat1, lon1, lat2, lon2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sind(dlat / 2)^2 + cosd(lat1) * cosd(lat2) * sind(dlon / 2)^2
    c = 2.0 * asind(sqrt(a))
    theta = atand(sind(dlon) * cosd(lat2),
        cosd(lat1) * sind(lat2) - sind(lat1) * cosd(lat2) * cosd(dlon))
    theta = (theta + 360) % 360
    return R * c * 0.5399565, theta
end

function inverse_haversine(lat1, lon1, distance, direction)
    lat2 = asind(sind(lat1) * cos(distance / R) + cosd(lat1) * sin(d / R) * cosd(direction))
    lon2 = lon1 + atand(sind(direction) * sin(distance / R) * cosd(lat1),
                       cos(distance / R) - sind(lat1) * sind(lat2))
    return lat2, lon2
end

function boatspeed(sp::SailingPolar, pointofsail, windspeed)
    winds, degrees, speeds = sp.winds, sp.degrees, sp.speeds
    udeg = findlast(t -> t <= pointofsail, degrees)
    odeg = findfirst(t -> t >= pointofsail, degrees)
    uvel = findlast(t -> t <= windspeed, winds)
    ovel = findfirst(t -> t >= windspeed, winds)
    if any(t -> t == nothing, [udeg, odeg, uvel, ovel])
        return -1.0
    end
    frac = (odeg == udeg && uvel == ovel) ? 1.0 :
            (odeg == udeg) ? (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel]) :
            (uvel == ovel) ? (pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) :
            ((pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) +
            (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel])) / 2
    return speeds[udeg, uvel] + frac * (speeds[odeg, ovel] - speeds[udeg, uvel])
end

sailingspeed(sp, azimuth, dir, ws) = boatspeed(sp, dir, ws) * cosd(abs(dir - azimuth))

function bestvectorspeed(sp::SailingPolar, dirtravel, dirwind, windspeed, dircur, velcur)
    pointofsail = (dirtravel - dirwind) % 360.0
    pointofsail = pointofsail < 0 ? pointofsail + 360.0 : pointofsail
    pointofsail = pointofsail > 180.0 ? 360.0 - pointofsail : pointofsail
    VMG = boatspeed(sp, pointofsail, windspeed)
    other, idx = findmax([sailingspeed(sp, pointofsail, x, windspeed) for x in degrees])
    if other > VMG
        pointofsail = degrees[idx]
        VMG = other
    end
    dirchosen = deg2rad(dirwind + pointofsail)
    wx, wy = VMG * sin(dirchosen), VMG * cos(dirchosen)
    curx, cury = velcur * sin(deg2rad(dircur)), velcur * cos(deg2rad(dircur))
    return rad2deg(atan(wy + cury, wx + curx)), sqrt((wx + curx)^2 + (wy + cury)^2)
end

function sailsegmenttime(sp::SailingPolar, p::SurfaceParameters, lat1, lon1, lat2, lon2)
    dir, distance = haversine(lat1, lon1, lat2, lon2)
    dir2, vel = bestvectorspeed(sp, dir, p.winddeg, p.windkts, p.currentdeg, p.currentkts)
    endlat2, endlon2 = inverse_haversine(lat1, lon1, distance, dir2)
println("plan: $lat2, $lon2   actual: $endlat2, endlon2")
    return distance / vel
end


end # module


using GeometryTypes
using .SailingPolars

# NB:  latitude (y) first then longitude (x) as per ISO 6709
Position = Point2f0
lat(p::Position) = p[1]
lon(p::Position) = p[2]

struct GridPoint
    pt::Position
    sp::SurfaceParameters
end

closestpoint(p, mat) = findmin(gp -> haversine(p[1], p[2], gp.pt[1], gp.pt[2])[1], mat)[2]

# data is at 10 minute (600 second) intervals for 20 x 20 matrix map below.
# Spacing is in 1/60 of a degree (1 minute) for lat and lon
#=
.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  x  x
.  .  .  .  .  .  .  .  .  F  .  .  .  .  .  .  .  .  x  x
.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  x  x
.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
.  .  x  x  .  .  .  .  .  .  x  .  .  .  .  .  .  .  .  .
.  .  x  x  .  .  .  .  .  x  x  x  .  .  .  .  .  .  .  .
.  .  .  .  .  .  .  .  x  x  x  x  x  .  .  .  .  .  .  .
.  .  .  .  .  .  .  .  x  x  x  x  x  .  .  .  .  .  .  .
.  .  .  .  .  .  .  .  .  x  x  x  x  x  .  .  .  .  .  .
.  .  .  x  x  .  .  .  .  .  x  x  x  x  .  .  .  .  .  .
.  .  .  x  x  .  .  .  .  .  .  x  x  x  x  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .  .  x  x  x  x  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .  .  x  x  x  x  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .  x  x  x  x  .  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .  x  x  x  x  .  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .  .  x  x  x  .  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .  .  x  x  .  .  .  .  .  .  .
.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
.  .  .  .  .  S  .  .  .  .  .  .  .  .  .  .  .  .  .  x
.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  x  x
=#

const forbidden = [
    [1, 19], [1,20], [2, 20], [4, 12], [4, 13], [5, 12], [5, 13], [5, 14], [6, 11], [6, 12],
    [6, 13], [6, 14], [7, 11], [7, 12], [7, 13], [7, 14], [8, 12], [8, 13], [8, 14], [8, 15],
    [9, 12], [9, 13], [9, 14], [9, 15], [10, 4], [10, 5], [10, 12], [10, 13], [10, 14],
    [10, 15], [11, 4], [11, 5], [11, 11], [11, 12], [11, 13], [11, 14], [12, 10], [12, 11],
    [12, 12], [12, 13], [13, 9], [13, 10], [13, 11], [13, 12], [14, 9], [14, 10], [14, 11],
    [14, 12], [15, 3], [15, 4], [15, 10], [15, 11], [15, 12], [16, 3], [16, 4], [16, 11],
    [18, 19], [18, 20], [19, 19], [19, 20],[20, 19], [20, 20],
]

function surround(x, y, mat, excluded)
    xmax, ymax = size(mat)
    return filter(0 <= p[1] <= xmax && 0 <= p[2] <= ymax && !(p in excluded),
        [[-1, -1], [-1, 0], [-1, 1], [0. -1], [0, 1], [1, -1], [1, 0], [1, 1]] .+ [x, y])
end

const startpos = Point2{Int}(1, 6)
const endpos = Point2{Int}(19, 10)
const pmat  = [Position(19.78 - 1/60 + i/60, -155.0 - 5/60 + j/60) for i in 0:19, j in 0:19]

function surfacebylongitude(lon)
    return lon < -155.1 ? SurfaceParameters(170.0, 30, 150, 0.5) :
           lon < -154.9 ? SurfaceParameters(165.0, 10, 150, 0.4) :
           lon < -154.8 ? SurfaceParameters(40.0, 30, 150, 0.3) :
                          SurfaceParameters(60.0, 40, 150, 0.2)
end

const gpoints = map(pt -> GridPoint(pt, surfacebylongitude(lon(pt))), pmat)

const filename = "polar.csv"
const sp = getpolardata(filename)

@show boatspeed(sp, 90, 19.0)
@show boatspeed(sp, 95, 19.0)
@show boatspeed(sp, 100, 19.0)

TimeSlice = Matrix{GridPoint}

mutable struct RoutingProblem
    timeinterval::Float64 # seconds between timeframe slices
    timeframe::Vector{TimeSlice}
    obstacleindices::Vector{Point2{Int}}
    startindex::Int
    start::Point2{Int}
    finish::Point2{Int}
end

mutable struct TimedPath
    duration::Float64
    path::Vector{Point2{Int}}
end

const routeprob = RoutingProblem(600.0, fill(gpoints, 200), forbidden, 1, startpos, endpos)

function minimumtimeroute(rp::RoutingProblem, sp::SailingPolar, )
    timedpaths = [TimedPath(0.0, [start])]
    mintime, minpath = 10_000_000.0, TimedPath(10_000_000.0, [])
    for (timeframe, i) in enumerate(rp.timeframe)
        newpaths = TimedPath[]
        for tpath in timedpaths
            if tpath.path[end] == rp.finish
                if tpath.duration < mintime
                    mintime = tpath.duration
                    minpath = tpath
                end
            else
                p1 = tpath.path[end]
                for p2 in surround(p1)
                    gp1, gp2 = timeframe[p1[1], p1[2]], timeframe[p2[1], p2[2]]
                    lat1, lon1, lat2, lon2 = gp1.pt[1], gp1.pt[2], gp2.pt[1], gp2.pt[2]
                    t = sailsegmenttime(sp, gp1.sp, lat1, lon1, lat2, lon2)
                    push!(newpaths, TimedPath(path.duration + t, [path; point]))
                end
            end
        end
        paths = newpaths
        if all(p -> p.duration >= mintime, paths)
            break
        end
    end
    return minpath
end

