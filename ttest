const files = ["top1", "des1", "ip1", "ip2", "top2", "ip3", "extra1", "ip1a", "ipcommon",
    "ip2a", "ip2b", "ip2c", "des1a", "des1b", "des1c", "des1a1", "des1a2", "des1c1"]

const numfile = Dict(files[i] => i for i in 1:length(files))

const dep = Dict(
    "top1" => ["des1", "ip1", "ip2"],
    "top2" => ["des1", "ip2", "ip3"],
    "ip1" => ["extra1", "ip1a", "ipcommon"],
    "ip2" => ["ip2a", "ip2b", "ip2c", "ipcommon"],
    "des1" => ["des1a", "des1b", "des1c"],
    "des1a" => ["des1a1", "des1a2"],
    "des1c" => ["des1c1", "extra1"])

#isdep(f1, f2) = (haskey(dep, f1) && (f2 in dep[f1] || any(x -> isdep(x, f2), dep[f1])))

istoplevel(file) = haskey(dep, file) && !any(x -> file in x, values(dep))

function compileorder(allfiles, deps)
    files, depens = deepcopy(allfiles), deepcopy(deps)
    levels = Vector{Vector{String}}()
    while true
        basefiles = filter(x -> !haskey(depens, x), files)
        if isempty(basefiles)
            break
        end
        push!(levels, basefiles)
        files = filter(x -> haskey(depens, x), files)
        for (k, v) in depens, file in basefiles
            if file in v
                depens[k] = filter(x -> x != file, depens[k])
            end
        end
        for k in keys(depens)
            if isempty(depens[k])
                delete!(depens, k)
            end
        end
    end
    levels
end

function alldeps(file, dep)
    ret = [file]
    if haskey(dep, file)
        deps = dep[file]
        append!(ret, deps)
        for f in deps
            append!(ret, alldeps(f, dep))
        end
    end
    return unique(ret)
end

function compileplan(file, dep, deporder)
    files = alldeps(file, dep)
    for (i, level) in enumerate(deporder)
        lfiles = filter(x -> x in level, files)
        println("Step $i: compile $lfiles")
    end
end

const dependencyordered = compileorder(files, dep)

println("The top level source files are: ", filter(istoplevel, files))

println("\nCompile order for top1:")
compileplan("top1", dep, dependencyordered)
println("\nCompile order for top2:")
compileplan("top2", dep, dependencyordered)

println("\nCompile plan for both:")
for (i, level) in enumerate(dependencyordered)
    lfiles = filter(x -> x in level, files)
    println("Step $i: compile $lfiles")
end



#=
The top level source files are: ["top1", "top2"]

Compile order for top1:
Step 1: compile ["des1b", "des1a1", "des1a2", "des1c1", "extra1", "ip1a", "ipcommon", "ip2a", "ip2b", "ip2c"]
Step 2: compile ["ip1", "ip2", "des1a", "des1c"]
Step 3: compile ["des1"]
Step 4: compile ["top1"]

Compile order for top2:
Step 1: compile ["ip3", "des1b", "des1a1", "des1a2", "des1c1", "extra1", "ip2a", "ip2b", "ip2c", "ipcommon"]
Step 2: compile ["ip2", "des1a", "des1c"]
Step 3: compile ["des1"]
Step 4: compile ["top2"]

Compile plan for both:
Step 1: compile ["ip3", "extra1", "ip1a", "ipcommon", "ip2a", "ip2b", "ip2c", "des1b", "des1a1", "des1a2", "des1c1"]
Step 2: compile ["ip1", "ip2", "des1a", "des1c"]
Step 3: compile ["des1"]
Step 4: compile ["top1", "top2"]


=#
