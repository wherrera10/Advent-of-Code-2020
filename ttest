using LightGraphs

const files = ["top1", "des1", "ip1", "ip2", "top2", "ip3", "extra1", "ip1a", "ipcommon",
    "ip2a", "ip2b", "ip2c", "des1a", "des1b", "des1c", "des1a1", "des1a2", "des1c1"]

const numfile = Dict(files[i] => i for i in 1:length(files))

const graph = SimpleDiGraph(length(files))

const dep = Dict(
    "top1" => ["des1", "ip1", "ip2"],
    "top2" => ["des1", "ip2", "ip3"],
    "ip1" => ["extra1", "ip1a", "ipcommon"],
    "ip2" => ["ip2a", "ip2b", "ip2c", "ipcommon"],
    "des1" => ["des1a", "des1b", "des1c"],
    "des1a" => ["des1a1", "des1a2"],
    "des1c" => ["des1c1", "extra1"])

for (k, v) in dep
    topnum = numfile[k]
    for f in v
        add_edge!(graph, numfile[f], topnum)
    end
end

isdep(f1, f2) = (haskey(dep, f1) && (f2 in dep[f1] || any(x -> isdep(x, f2), dep[f1])))

istoplevel(file) = haskey(dep, file) && !any(x -> file in x, values(dep))

function compileorder(allfiles, deps)
    files, depens = deepcopy(allfiles), deepcopy(deps)
    levels = Vector{Vector{String}}()
    while true
        files = filter(x -> !haskey(depens, x), files)
        if isempty(files)
            break
        end
        push!(levels, files)
        for (k, v) in depens, file in files
            if file in v
                depens[k] = filter(x -> x != file, depens[k])
            end
        end
        for k in keys(depens)
            if isempty(depens[k])
                delete!(depens, k)
            end
        end
    end
    levels
end

dependencyordered = compileorder(files, dep)

function compileorder(file)
    levels = Vector{Vector{String}}()
    for (i, filelist) in enumerate(dependencyordered)
        push!(levels, String[])
        for f in filelist
            if file == f || isdep(file, f)
                push!(levels[end], f)
            end
        end
    end
    levels
end

println("The toplevels are: ", filter(istoplevel, files))

println("compile order for top1: ", compileorder("top1"))
println("compile order for top2: ", compileorder("top2"))

#=
The task is to create a program that given a graph of the dependency:

Determines the top levels from the dependencies and show them.
Extracts a compile order of files to compile any given (usually top level) file.
Give a compile order for file top1.
Give a compile order for file top2.
You may show how to compile multiple top levels as a stretch goal
=#
