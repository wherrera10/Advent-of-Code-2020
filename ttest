using LightGraphs

const files = ["top1", "des1", "ip1", "ip2", "top2", "ip3", "extra1", "ip1a", "ipcommon",
    "ip2a", "ip2b", "ip2c", "des1a", "des1b", "des1c", "des1a1", "des1a2", "des1c1"]

const numfile = Dict(files[i] => i for i in 1:length(files))

const graph = SimpleDiGraph(length(files))

const dep = Dict(
    "top1" => ["des1", "ip1", "ip2"],
    "top2" => ["des1", "ip2", "ip3"],
    "ip1" => ["extra1", "ip1a", "ipcommon"],
    "ip2" => ["ip2a", "ip2b", "ip2c", "ipcommon"],
    "des1" => ["des1a", "des1b", "des1c"],
    "des1a" => ["des1a1", "des1a2"],
    "des1c" => ["des1c1", "extra1"])

for (k, v) in dep
    topnum = numfile[k]
    for f in v
        add_edge!(graph, numfile[f], topnum)
    end
end

isdep(f1, f2) = (haskey(dep, f1) && (f2 in dep[f1] || any(x -> isdep(x, f2), dep[f1])))

istoplevel(file) = haskey(dep, file) && !any(x -> file in x, values(dep))

function compileorder(file)
    ret = [[file]]
    if haskey(dep, file)
        pushfirst!(ret, dep[file])
        for f in dep[file]
            
        end
    end
    ret
end

println("The toplevels are: ", filter(istoplevel, files))

println("compile order for top1: ", compileorder("top1"))
println("compile order for top2: ", compileorder("top2"))

#=
The task is to create a program that given a graph of the dependency:

Determines the top levels from the dependencies and show them.
Extracts a compile order of files to compile any given (usually top level) file.
Give a compile order for file top1.
Give a compile order for file top2.
You may show how to compile multiple top levels as a stretch goal
=#
