import Base.iterate, Base.IteratorSize, Base.IteratorEltype

function filldecreasing!(vec, pos)
    n = vec[pos]
    for i in pos-1:-1:1
        n = (n <= 0) ? 1 : n - 1
        vec[i] = n
    end
    return vec
end

struct Esthetic
    lowerlimit::Int
    base::Int
    upperlimit::Int
    Esthetic(n, bas, m = typemax(Int)) = new(nextesthetic(n, bas), bas, m)
end

Base.IteratorSize(n::Esthetic) = Base.IsInfinite()
Base.IteratorEltype(n::Esthetic) = Int128

toInt(dig, bas) = foldr((i, j) -> i + bas * j, dig)
nextesthetic(n, bas) = toInt(increment!(digits(n, base=bas), bas, true), bas)

function increment!(dig, bas, allowequal=false)
    len = length(dig)
    if len == 1
        return allowequal ? max(1, dig[1]) : dig[1] > bas - 2 ? [1, 0] : [dig[1] + 1]
    end
    for i in len:-1:2
        if !allowequal && i == 2 && dig[1] in [dig[2] - 1, dig[2] + 1]
            dig[1] += 1
        end
        if dig[i - 1] != dig[i] -1 && dig[i - 1] != dig[i] + 1
            if dig[i - 1] < dig[i] - 1
                dig[i - 1] = dig[i] - 1
                dig = filldecreasing!(dig, i - 1)
            elseif dig[i - 1] == dig[i] && dig[i] < bas - 1
                dig[i - 1] = dig[i] + 1
                dig = filldecreasing!(dig, i - 1)
            else # dig[i - 1] > dig[i] + 1 so will get next dig via recursion
                dig[i] = dig[i] + 1
                dig = filldecreasing!(dig, i)
                dig = increment!(dig, bas, true)
            end
            break
        end
    end
    return dig
end
 
function Base.iterate(es::Esthetic, state=Int[])
    state = isempty(state) ? digits(es.lowerlimit, base=es.base) : increment!(state, es.base)
    n = toInt(state, es.base)
    return n <= es.upperlimit ? (
    n, state) : nothing
end

for b in 2:16
    bmin, bmax = 4b, 6b
    println("The $(4b) through $(6b) esthetic numbers of base $b are:")
    println(string.(collect(Iterators.take(Esthetic(1, b), bmax)), base=b)[bmin:bmax])
end

