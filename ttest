module AVLTrees

import Base.print
export AVLNode, AVLTree, insert, delete_key


mutable struct AVLNode{T}
    key::T
    balance::Int
    left::MaybeAVL
    right::MaybeAVL
    parent::MaybeAVL
end
AVLNode(k, b, l, r, p) where T <: Real = AVLNode(k, b, l, r, p)
AVLNode(k::T) where T <: Real = AVLNode(k, 0, nothing, nothing, nothing)
AVLTree(typ::Type) = AVLNode(typ(0))
const MaybeAVL = Union{AVLNode, Nothing}

@enum Direction LEFT RIGHT

function insert(node, key)
    if node == nothing
        node = AVLNode(key)
        return true
    end
    n, parent = MaybeAVL(node), MaybeAVL(nothing)
    while true
        if n.key == key
            return false
        end
        parent = n
        goleft = n.key > key
        n = goleft ? n.left : n.right
        if n == nothing
            if goleft
                parent.left = AVLNode(key, 0, nothing, nothing, parent)
            else
                parent.right = AVLNode(key, 0, nothing, nothing, parent)
            end
            rebalance(parent)
            break
        end
    end
    rebalance(node)
    return true
end

function delete_key(node, delkey)
    root == nothing && return nothing
    n, parent = MaybeAVL(node), MaybeAVL(node)
    delnode, child = MaybeAVL(nothing), MaybeAVL(node)
    while child != nothing
        parent = n
        n = child
        child = delkey >= n.key ? n.right : n.left
        if delkey == n.key
            delnode = n
        end
    end
    if delnode != nothing
        delnode.key = n.key
        child = n.left != nothing ? n.left : n.right
        if node.key == delkey
            node = child
        else
            if parent.left == n
                parent.left = child
            else
                parent.right = child
            end
            rebalance(parent)
        end
    end
end

function rebalance(n)
    n == nothing && return nothing
    x = n.balance
    if x == -2
        if height(n.left.left) >= height(n.left.right)
            n = rotate(n, RIGHT)
        else
            n = rotate_twice(n, LEFT, RIGHT)
        end
    elseif x == 2
        if height(n.right.right) >= height(n.right.left)
            n = rotate(n, LEFT)
        else
            n = rotate_twice(n, RIGHT, LEFT)
        end
    end
    if n != nothing && n.parent != nothing
        rebalance(n.parent)
    end
end

function rotate(a, direction)
    (a == nothing || a.parent == nothing) && return
    b = direction == LEFT ? a.right : a.left
    b == nothing && return
    b.parent = a.parent
    if direction == LEFT
        a.right = b.left
    else
        a.left  = b.right
    end
    if a.right != nothing
        a.right.parent = a
    end
    if direction == LEFT
        b.left = a
    else
        b.right = a
    end
    a.parent = b
    if b.parent != nothing
        if b.parent.right == a
            b.parent.right = b
        else
            b.parent.left = b
        end
    end
    setbalance([a, b])
    return b
end

function rotate_twice(n, dir1, dir2)
    n.left = rotate(n.left, dir1)
    rotate(n, dir2)
end

height(n) = n == nothing ? 0 : 1 + max(height(n.left), height(n.right))

function setbalance(nodes)
    for n in nodes
        n.balance = height(n.right) - height(n.left)
    end
end

function Base.print(io::IO, n::AVLNode)
    if n != nothing
        n.left != nothing && print(io, n.left)
        print(io, "<$(n.key):$(n.balance)> ")
        n.right != nothing && print(io, n.right)
    end
end

end # module

using .AVLTrees

const tree = AVLTree(Int)

println("Inserting 20 values.")
foreach(x -> insert(tree, tree, x), rand(collect(1:80), 18))
println("Printing tree after insertion: ")
println(tree)



