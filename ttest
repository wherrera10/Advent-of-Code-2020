#=
Support arbitrary precision real numbers, both positive and negative;

Provide ways to convert to and from text strings, using digits '+', '-' and '0'
(unless you are already using strings to represent balanced ternary; but see requirement 5).

Provide ways to convert to and from native integer and real type (unless, improbably,
your platform's native integer type is balanced ternary). If your native integers can't
support arbitrary length, overflows during conversion must be indicated.

Provide ways to perform addition, negation and multiplication directly on balanced
ternary integers; do not convert to native integers first.

Make your implementation efficient, with a reasonable definition of "efficient"
(and with a reasonable definition of "reasonable").

The Template should successfully handle these multiplications in other bases.
In particular Septemvigesimal and "Balanced base-27".
=#
import Base.print, Base.+, Base.-, Base.*, Base./

abstract type BalancedBaseDigitArray end

mutable struct BalancedTernary <: BalancedBaseDigitArray
    dig::Vector{Int8}
    p::Int
    BalancedTernary(arr::Vector=zeros(Int8, 1), i=0) = new(Int8.(arr), i)
end

BalancedTernary(s::String) = BalancedTernary([c == '-' ? -1 : c == '0' ? 0 : 1 for c in s]) # 2
function BalancedTernary(n::Int)        # 1, 3
    if n < 0
        return BalancedTernary(BalancedTernary(-n).dig .* Int8(-1))
    elseif n == 0
        return BalancedTernary([0])
    else
        arr = Vector{Int8}()
        while n != 0
            push!(arr, [1, -1, 0][mod1(n, 3)])
            n = div(-~n, 3)
        end
        return BalancedTernary(arr)
    end
end

String(b::BalancedTernary) = String([['-', '0', '+'][c + 2] for c in b.dig])  # 3
Int(b::BalancedTernary) = sum(t -> 3^(t[1] - 1) * t[2], enumerate(b.dig))     # 3

function canonicalize!(b::BalancedTernary)
    for (i, d) in enumerate(b.dig)
        if d > 1
            b.dig[i] -= 3
            if i == length(b.dig)
                push!(b.dig, 0)
            end
            b.dig[i + 1] += 1
        elseif d < -1
            b.dig[i] += 3
            if i == length(b.dig)
                push!(b.dig, 0)
            end
            b.dig[i + 1] -= 1
        end
    end
    if (i = findlast(x -> x != 0, b.dig)) != nothing
        resize!(b.dig, i)
    else
        b.dig = [0]
    end
    if b.p > 0 && (i = findfirst(x -> x != 0, b.dig)) != nothing
        removable = min(b.p, i)
        b.dig = b.dig[removable:end]
        b.p -= removable
    end
    return b
end

align!(b, n::Int) = if (i = n - b.p) > 0 b.dig = [zeros(Int8, i; b.dig]; b.p = i end
align!(b1, b2::BalancedTernary) = if b1.p > b2.p align!(b2, b1.p) else align!(b1, b2.p) end

# The following should work with any base number where dig is a similar array
# and the proper constructors, canon, and conversion routines are defined             # 6

Base.print(io::IO, b::BalancedBaseDigitArray) = print(io, String(b))


function +(b1::T, b2::T) where T <: BalancedBaseDigitArray                    # 4
    longlen, shortlen = length(b1.dig), length(b2.dig)
    if longlen == 0
        return b2
    elseif shortlen == 0
        return b1
    end
    if longlen < shortlen
        b1, b2, longlen , shortlen = b2, b1, shortlen, longlen
    end
    arr = deepcopy(b1.dig)
    arr[1:shortlen] .+= b2.dig
    return canonicalize!(T(arr))
end

-(b1::T) where T <: BalancedBaseDigitArray = T(b1.dig .* -1)                  # 4
-(b1::T, b2::T) where T <: BalancedBaseDigitArray = +(b1, -b2)                # 4

function *(b1::T, b2::T) where T <: BalancedBaseDigitArray                    # 4
    bsum = T()
    for (i, j) in enumerate(b2.dig)
        bsum += T([zeros(Int8, i - 1); b1.dig .* j])
    end
    return canonicalize!(bsum)
end

b1 = BalancedTernary(12)
b2 = BalancedTernary(20)

println(Int(b1))
println(Int(b2))

println(b1 + b2, "  ", Int(b1 + b2))
println(b1 * b2, "  ", Int(b1 * b2))

println(Int64(BalancedTernary(-250)))
println(Int(BalancedTernary("-+-+")))
