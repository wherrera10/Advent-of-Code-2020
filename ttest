

function hammingsequence(N::Int)
    if N < 1
        throw("Hamming sequence index must be a positive integer")
    end
    ham = Vector{BigInt}([1])
    base2, base3, base5 = 1, 1, 1
    next2, next3, next5 = BigInt(2), BigInt(3), BigInt(5)
    for _ in 1:N-1
        x = min(next2, next3, next5)
        push!(ham, x)
        next2 <= x && (base2 += 1; next2 = 2ham[base2])
        next3 <= x && (base3 += 1; next3 = 3ham[base3])
        next5 <= x && (base5 += 1; next5 = 5ham[base5])
    end
    ham
end

function counthumbledigits(maxdigits, returnsequencelength=50)
    n, count, adjustindex  = BigInt(1), 0, BigInt(0)
    humble, savesequence = Vector{BigInt}([1]), Vector{BigInt}()
    base2, base3, base5, base7 = 1, 1, 1, 1
    next2, next3, next5, next7 = BigInt(2), BigInt(3), BigInt(5), BigInt(7)
    digitcounts= Dict{Int, Int}(1 => 1)
    while n < BigInt(10)^(maxdigits+1)
        n = min(next2, next3, next5, next7)
        push!(humble, n)
        count += 1
        if count == returnsequencelength
            savesequence = deepcopy(humble)
        elseif count > 1000000
            popfirst!(humble)
            adjustindex += 1
        end
        placesbase10 = length(string(n))
        if haskey(digitcounts, placesbase10)
            digitcounts[placesbase10] += 1
        else
            digitcounts[placesbase10] = 1
        end
        next2 <= n && (base2 += 1; next2 = 2 * humble[base2 - adjustindex])
        next3 <= n && (base3 += 1; next3 = 3 * humble[base3 - adjustindex])
        next5 <= n && (base5 += 1; next5 = 5 * humble[base5 - adjustindex])
        next7 <= n && (base7 += 1; next7 = 7 * humble[base7 - adjustindex])
    end
    savesequence, digitcounts
end

counthumbledigits(3)

@time first120, digitcounts = counthumbledigits(60)

println("The first 50 humble numbers are: $first120\n\nDigit counts of humble numbers:")
for ndigits in sort(collect(keys(digitcounts)))[1:end-1]
    println(lpad(digitcounts[ndigits], 10), " have ", lpad(ndigits, 3), " digits.")
end


