#=
=={{header|Julia}}==
{{trans|Perl 6}}
<lang julia>
=#
using DataStructures # for deque
# numtext2ordinal is from the "Spelling of ordinal numbers" task, which uses code
# from the "Number names" task, updated for Julia 1.0.
 
const stext = ["one", "two", "three", "four", "five",
               "six", "seven", "eight", "nine"]
const teentext = ["eleven", "twelve", "thirteen", "fourteen",
                  "fifteen", "sixteen", "seventeen",
                  "eighteen", "nineteen"]
const tenstext = ["ten", "twenty", "thirty", "forty", "fifty",
                  "sixty", "seventy", "eighty", "ninety"]
const ordstext = ["million", "billion", "trillion",
                  "quadrillion", "quintillion", "sextillion",
                  "septillion", "octillion", "nonillion",
                  "decillion", "undecillion", "duodecillion",
                  "tredecillion", "quattuordecillion", "quindecillion",
                  "sexdecillion", "septendecillion", "octodecillion",
                  "novemdecillion", "vigintillion"]
 
function normalize_digits!(a)
    while  0 < length(a) && a[end] == 0
        pop!(a)
    end
    return length(a)
end
 
function digits2text!(d, use_short_scale=true)
    ndig = normalize_digits!(d)
    0 < ndig || return ""
    if ndig < 7
        s = ""
        if 3 < ndig
            t = digits2text!(d[1:3])
            s = digits2text!(d[4:end])*" thousand"
            0 < length(t) || return s
            if occursin("and", t)
                return s*" "*t
            else
                return s*" and "*t
            end
        end
        if ndig == 3
            s *= stext[pop!(d)]*" hundred"
            ndig = normalize_digits!(d)
            0 < ndig || return s
            s *= " and "
        end
        1 < ndig || return s*stext[pop!(d)]
        j, i = d
        j != 0 || return s*tenstext[i]
        i != 1 || return s*teentext[j]
        return s*tenstext[i]*"-"*stext[j]
    end
    s = digits2text!(d[1:6])
    d = d[7:end]
    dgrp = use_short_scale ? 3 : 6
    ord = 0
    while(dgrp < length(d))
        ord += 1
        t = digits2text!(d[1:dgrp])
        d = d[(dgrp+1):end]
        0 < length(t) || continue
        t = t*" "*ordstext[ord]
        if length(s) == 0
            s = t
        else
            s = t*" "*s
        end
    end
    ord += 1
    t = digits2text!(d)*" "*ordstext[ord]
    0 < length(s) || return t
    return t*" "*s
end
 
function num2text(n, use_short_scale=true)
    -1 < n || return "minus "*num2text(-n, use_short_scale)
    0 < n || return "zero"
    toobig = use_short_scale ? big(10)^66 : big(10)^126
    n < toobig || return "too big to say"
    return digits2text!(digits(n, base=10), use_short_scale)
end

const irregular = Dict("one" => "first", "two" => "second", "three" => "third",
                       "five" => "fifth", "nine" => "ninth", "twelve" => "twelfth")
const suffix = "th"
const ysuffix = "ieth"
 
function numtext2ordinal(s)
    lastword = split(s)[end]
    redolast = split(lastword, "-")[end]
    if redolast != lastword
        lastsplit = "-"
        word = redolast
    else
        lastsplit = " "
        word = lastword
    end
    firstpart = reverse(split(reverse(s), lastsplit, limit=2)[end])
    firstpart = (firstpart == word) ? "": firstpart * lastsplit
    if haskey(irregular, word)
        word = irregular[word]
    elseif word[end] == 'y'
        word = word[1:end-1] * ysuffix
    else
        word = word * suffix
    end
    firstpart * word
end

const start = "Four is the number of letters in the first word of this sentence, "
const (word2, word3) = ("in", "the")

struct CountLetters
    sentence::String
    words::Deque{String}
    CountLetters(s) = new(s=start, map(x->x[1],collect(eachmatch(r"(\w+)", s))), 0)
end

function Base.iterate(iter::CountLetters, state = 1)
    if length(iter.words) < 1
        return nothing
    end
    returnword = popfirst!(iter.words)
    nextwordindex = state + 1
    nextword = front(iter.words)
    push!(iter.words, num2text(nextword), word2, word3, numtext2ordinal(nextwordindex))
    (length(nextword), nextwordindex)
end
