import Main.≈

const radius = 1.0   # simplifies calculations
const θ = π / 6      # 30 degrees

struct Point
    x::Float32
    y::Float32
end

Main.:≈(p1::Point, p2::Point) = ≈(p1.x, p2.x, atol= 0.00001) && ≈(p1.y, p2.y, atol=0.00001)

rightwardfrom(start, angle) = Point(start.x + sin(angle + θ), start.y + cos(angle + θ))
leftwardfrom(start, angle) = Point(start.x + sin(angle - θ), start.y + cos(angle - θ))

struct RailwayCircuit
    startpoint::Point
    startdirection::Float64
    turns::Array{Int, 1}  # 1 for right, -1 for left
    RailwayCircuit(turnarray=Bool[]) = new(Point(0, 0), 0, turnarray)
end

function issymmetry(c1, c2)
    return length(c1) == length(c2) && sum(c1) == sum(c2) &&
        any(n -> c1 == circshift(c2, n), 0:length(c2)-1)
end

isduplicate(c1, c2) = issymmetry(c1, c2) || issymmetry(c1, [-x for x in c2])

function points(tracks::RailwayCircuit)
    ret, point, ϕ = [tracks.startpoint], tracks.startpoint, tracks.startdirection
    for turn in tracks.turns
        if turn == 1
            point = rightwardfrom(point, ϕ)
            ϕ += θ
        else
            point = leftwardfrom(point, ϕ)
             ϕ -= θ
        end
        push!(ret, point)
    end
    return ret
end

function isvalidcircuit(tracks)
    return sum(tracks.turns) % 12 != 0 ? false : (c = points(tracks); c[1] ≈ c[end])
end

function allvalidcircuits(N, doprint)
    found = RailwayCircuit[]
    println("\nFor N of $N: ")
    for i in 0:2^N-1
        rc = RailwayCircuit([d == 0 ? -1 : 1 for d in digits(i, base=2, pad=N)])
        if isvalidcircuit(rc) & all(x -> !isduplicate(x.turns, rc.turns), found)
            doprint && println(rc.turns)
            push!(found, rc)
        end
    end
    println("There are ", length(found), " unique valid circuits.")
end

for i in 12:4:32
    allvalidcircuits(i, i < 24)
end

