module AVLTrees

import Base.print
export AVLNode, AVLTree, insert, delete_key

@enum Direction LEFT RIGHT
avlhash(x) = Int32(hash(x) & 0xfffffff)

mutable struct AVLNode{T}
    value::T
    key::Int32
    balance::Int32
    left::Union{AVLNode, Nothing}
    right::Union{AVLNode, Nothing}
    parent::Union{AVLNode, Nothing}
end
AVLNode(v::T, b, l, r, p) where T <: Real = AVLNode(v, avlhash(v), Int32(b), l, r, p)
AVLNode(v::T, h, b::Int64, l, r, p) where T <: Real = AVLNode(v, h, Int32(b), l, r, p)
AVLNode(v::T) where T <: Real = AVLNode(v, avlhash(v), Int32(0), nothing, nothing, nothing)

# The root has a hash value of 0, which should not occur with other AVLNode values.
AVLTree(typ::Type) = AVLNode(typ(0), Int32(0), Int32(0), nothing, nothing, nothing)
const MaybeAVL = Union{AVLNode, Nothing}

height(node::MaybeAVL) = (node == nothing) ? 0 : 1 + max(height(node.right), height(node.left))

function insert(node, value)
    if node == nothing
        node = AVLNode(value)
        return true
    end
    key, n, parent::MaybeAVL = avlhash(value), node, nothing
    while true
        if n.key == key
            return false
        end
        parent = n
        ngreater = n.key > key
        n = ngreater ? n.left : n.right
        if n == nothing
            if ngreater
                parent.left = AVLNode(value, key, 0, nothing, nothing, parent)
            else
                parent.right = AVLNode(value, key, 0, nothing, nothing, parent)
            end
            setbalance(parent)
            rebalance(parent)  # this needs to recurse up
            break
        end
    end
    return true
end

function insert(node::AVLNode, othernode::MaybeAVL)
    othernode == nothing && return false
    n, parent = MaybeAVL(node), MaybeAVL(node)
    while true
        if n.key == key
            return false
        end
        parent = n
        ngreater = n.key > othernode.key
        n = ngreater ? n.left : n.right
        if n == nothing
            if ngreater
                parent.left = othernode
            else
                parent.right = othernode
            end
            setbalance(parent)
            rebalance(parent)  # this needs to recurse up
            break
        end
    end
    return true
end

function deletekey(node, delkey)
    node == nothing && return nothing
    n, parent = MaybeAVL(node), MaybeAVL(node)
    delnode, child = MaybeAVL(nothing), MaybeAVL(node)
    while child != nothing
        parent, n = n, child
        child = delkey >= n.key ? n.right : n.left
        if delkey == n.key
            delnode = n
        end
    end
    delnode == nothing && return false
    # now delnode == n, and has the key we were looking for and its parent is parent
    if parent.left == delnode
        parent.left = child
    else
        parent.right = child
    end
    insert(child, delnode.right == child ? delnode.left : delnode.right)
    setbalance(parent)
    rebalance(parent)
    return true
end

function rebalance(node::MaybeAVL)
    node == nothing && return nothing
    node.balance = height(node)
    if node.balance < -1
        if height(node.left.left) >= height(node.left.right)
            node = rotate(node, RIGHT)
        else
            node = rotatetwice(node, LEFT, RIGHT)
        end
    elseif node.balance > 1
        if node.right != nothing && height(node.right.right) >= height(node.right.left)
            node = rotate(node, LEFT)
        else
            node = rotatetwice(node, RIGHT, LEFT)
        end
    end
    node != nothing && rebalance(node.parent)
end

function rotate(a, direction)
    (a == nothing || a.parent == nothing) && return nothing
    b = direction == LEFT ? a.right : a.left
    b == nothing && return
    b.parent = a.parent
    if direction == LEFT
        a.right = b.left
    else
        a.left  = b.right
    end
    if a.right != nothing
        a.right.parent = a
    end
    if direction == LEFT
        b.left = a
    else
        b.right = a
    end
    a.parent = b
    if b.parent != nothing
        if b.parent.right == a
            b.parent.right = b
        else
            b.parent.left = b
        end
    end
    setbalance([a, b])
    return b
end

function rotatetwice(n, dir1, dir2)
    n.left = rotate(n.left, dir1)
    rotate(n, dir2)
end

setbalance(n::AVLNode) = begin n.balance = height(n.right) - height(n.left) end
setbalance(n::Nothing) = 0
setbalance(nodes::Vector) = for n in nodes setbalance(n) end

function Base.print(io::IO, n::MaybeAVL)
    if n != nothing
        n.left != nothing && print(io, n.left)
        print(io, "<$(n.value):$(n.balance)> ")
        n.right != nothing && print(io, n.right)
    end
end

end # module

using .AVLTrees

const tree = AVLTree(Int)

println("Inserting 20 values.")
foreach(x -> insert(tree, x), rand(collect(1:80), 18))
println("Printing tree after insertion: ")
println(tree)




