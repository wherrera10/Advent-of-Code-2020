module SailingPolars

using DelimitedFiles

export SailingPolar, SurfaceParameters, getpolardata, deg2rad, rad2deg, cartesian2polar
export polar2cartesian, haversine, inverse_haversine, boatspeed, bestvectorspeed
export sailingspeed, sailsegmenttime

struct SailingPolar
    winds::Vector{Float32}
    degrees::Vector{Float32}
    speeds::Matrix{Float32} # speeds[wind direction degrees, windspeed knots]
end

struct SurfaceParameters
    winddeg::Float32
    windkts::Float32
    currentdeg::Float32
    currentkts::Float32
end

function getpolardata(filename)
    datacells, headercells = readdlm(filename, ';', header=true)
    winds = map(x -> parse(Float32, x), headercells[2:end])
    degrees = datacells[:, 1]
    speeds = datacells[:, 2:end]
    return SailingPolar(winds, degrees, speeds)
end

const R = 6372800  # earth approximate radius in meters
deg2rad(deg) = (deg * π / 180.0 + 2π) % 2π
rad2deg(rad) = (rad * (180.0 / π) + 360.0) % 360.0
cartesian2polar(x, y) = sqrt(x * x + y * y), atand(x, y)
polar2cartesian(r, deg) = r .* sincosd(deg)

function haversine(lat1, lon1, lat2, lon2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sind(dlat / 2)^2 + cosd(lat1) * cosd(lat2) * sind(dlon / 2)^2
    c = 2.0 * asind(sqrt(a))
    theta = atand(sind(dlon) * cosd(lat2),
        cosd(lat1) * sind(lat2) - sind(lat1) * cosd(lat2) * cosd(dlon))
    theta = (theta + 360) % 360
    return R * c * 0.5399565, theta
end

function inverse_haversine(lat1, lon1, distance, direction)
    lat2 = asind(sind(lat1) * cos(distance / R) + cosd(lat1) * sin(distance / R) * cosd(direction))
    lon2 = lon1 + atand(sind(direction) * sin(distance / R) * cosd(lat1),
                       cos(distance / R) - sind(lat1) * sind(lat2))
    return lat2, lon2
end

function boatspeed(sp::SailingPolar, pointofsail, windspeed)
    winds, degrees, speeds = sp.winds, sp.degrees, sp.speeds
    udeg = findlast(t -> t <= pointofsail, degrees)
    odeg = findfirst(t -> t >= pointofsail, degrees)
    uvel = findlast(t -> t <= windspeed, winds)
    ovel = findfirst(t -> t >= windspeed, winds)
    if any(t -> t == nothing, [udeg, odeg, uvel, ovel])
        return -1.0
    end
    frac = (odeg == udeg && uvel == ovel) ? 1.0 :
            (odeg == udeg) ? (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel]) :
            (uvel == ovel) ? (pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) :
            ((pointofsail - degrees[udeg]) / (degrees[odeg] - degrees[udeg]) +
            (windspeed - winds[uvel]) / (winds[ovel] - winds[uvel])) / 2
    return speeds[udeg, uvel] + frac * (speeds[odeg, ovel] - speeds[udeg, uvel])
end

sailingspeed(sp, azimuth, dir, ws) = boatspeed(sp, dir, ws) * cosd(abs(dir - azimuth))

function bestvectorspeed(sp::SailingPolar, dirtravel, dirwind, windspeed, dircur, velcur)
    pointofsail = (dirtravel - dirwind) % 360.0
    pointofsail = pointofsail < 0 ? pointofsail + 360.0 : pointofsail
    pointofsail = pointofsail > 180.0 ? 360.0 - pointofsail : pointofsail
    VMG = boatspeed(sp, pointofsail, windspeed)
    other, idx = findmax([sailingspeed(sp, pointofsail, x, windspeed) for x in sp.degrees])
    if other > VMG
        pointofsail = sp.degrees[idx]
        VMG = other
    end
    dirchosen = deg2rad(dirwind + pointofsail)
    wx, wy = VMG * sin(dirchosen), VMG * cos(dirchosen)
    curx, cury = velcur * sin(deg2rad(dircur)), velcur * cos(deg2rad(dircur))
    return rad2deg(atan(wy + cury, wx + curx)), sqrt((wx + curx)^2 + (wy + cury)^2)
end

function sailsegmenttime(sp::SailingPolar, p::SurfaceParameters, lat1, lon1, lat2, lon2)
    distance, dir = haversine(lat1, lon1, lat2, lon2)
    dir2, vel = bestvectorspeed(sp, dir, p.winddeg, p.windkts, p.currentdeg, p.currentkts)
    endlat2, endlon2 = inverse_haversine(lat1, lon1, distance, dir2)
    # minutes/s * m / (knots * (m/s / knot)) = minutes
    return (1 / 60) * distance / (vel * 1.94384)
end


end # module


module SailingNavigation

export Position, lat, lon, GridPoint, TimeSlice, TimedPath, closestpoint, surround
export RoutingProblem, minimumtimeroute

using GeometryTypes
using ..SailingPolars

# NB:  latitude (y) first then longitude (x) as per ISO 6709
Position = Point2f0
lat(p::Position) = p[1]
lon(p::Position) = p[2]

struct GridPoint
    pt::Position
    sp::SurfaceParameters
end

TimeSlice = Matrix{GridPoint}

mutable struct RoutingProblem
    timeinterval::Float64 # seconds between timeframe slices
    timeframe::Vector{TimeSlice}
    obstacleindices::Vector{Point2{Int}}
    startindex::Int
    start::Point2{Int}
    finish::Point2{Int}
    allowrepeatvisits::Bool
end

mutable struct TimedPath
    duration::Float64
    path::Vector{Point2{Int}}
end

closestpoint(p, mat) = findmin(gp -> haversine(p[1], p[2], gp.pt[1], gp.pt[2])[1], mat)[2]

function surround(p, mat, excluded)
    neighbors = Point2{Int}[(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    (xmax, ymax) = size(mat)
    return filter(q -> 1 <= q[1] <= xmax && 1 <= q[2] <= ymax && !(q in excluded),
        [x + p for x in neighbors])
end

function minimumtimeroute(rp::RoutingProblem, sp::SailingPolar)
    timedpaths = [TimedPath(0.0, [rp.start])]
    completed, mintime, minpath = false, 10_000_000.0, TimedPath(10_000_000.0, [])
    for (i, timeframe) in enumerate(rp.timeframe)
        newpaths = TimedPath[]
        println("Checking ", length(timedpaths), " paths of length ",
            length(timedpaths[1].path) - 1)
        for tpath in timedpaths
            if tpath.path[end] == rp.finish
                completed = true
                push!(newpaths, tpath)
            else
                p1 = tpath.path[end]
                for p2 in surround([p1[1], p1[2]], timeframe, rp.obstacleindices)
                    !rp.allowrepeatvisits && p2 in tpath.path && continue
                    gp1, gp2 = timeframe[p1[1], p1[2]], timeframe[p2[1], p2[2]]
                    lat1, lon1, lat2, lon2 = gp1.pt[1], gp1.pt[2], gp2.pt[1], gp2.pt[2]
                    t = sailsegmenttime(sp, gp1.sp, lat1, lon1, lat2, lon2)
                    path = deepcopy(tpath.path)
                    push!(path, p2)
                    push!(newpaths, TimedPath(tpath.duration + t, path))
                end
            end
        end
        timedpaths = unique(newpaths)
        if completed
            mindur = minimum(map(x -> x.duration, timedpaths))
            finished = filter(x -> x.path[end] == rp.finish, timedpaths)
            minfindur, idx = findmin(map(x -> x.duration, finished))
            println("Current finished minimum: ", finished[idx], ", others $mindur")
            if mindur == minfindur
                minpath = finished[idx]
                break
            end
        end
    end
    return minpath
end

end # module

using GeometryTypes
using .SailingNavigation, .SailingPolars

#=
x  .  .  F  .  .  x  .  x
.  .  .  .  .  .  .  x  x
x  .  .  x  x  x  .  .  .
.  .  x  x  x  x  .  x  x
x  .  .  .  x  x  .  x  .
x  .  .  .  x  x  .  x  .
.  .  .  .  x  .  .  x  .
x  .  .  .  .  .  .  x  .
.  .  .  S  .  .  .  .  .
=#
const forbidden = Point2{Int}.([
    [1, 8], [2, 1], [2, 8], [3, 5], [3, 8], [4, 1], [4, 5], [4, 6], [4, 8], [5, 1],
    [5, 5], [5, 6], [5, 8], [6, 3], [6, 4], [6, 5], [6, 6], [6, 8], [6, 9], [7, 1],
    [7, 4], [7, 5], [7, 6], [8, 8], [8, 9], [9, 1], [9, 7], [9, 9],
])

function surfacebylongitude(lon)
    return lon < -155.03 ? SurfaceParameters(-5.0, 8, 150, 0.5) :
           lon < -155.99 ? SurfaceParameters(-90.0, 20, 150, 0.4) :
                           SurfaceParameters(180.0, 25, 150, 0.3)
end

const startpos = Point2{Int}(1, 4)
const endpos = Point2{Int}(9, 4)
const pmat  = [Position(19.78 - 1/60 + i/60, -155.0 - 5/60 + j/60) for i in 0:8, j in 0:8]
const gpoints = map(pt -> GridPoint(pt, surfacebylongitude(lon(pt))), pmat)
const routeprob = RoutingProblem(600.0, fill(gpoints, 200), forbidden, 1, startpos, endpos, false)

const filename = "polar.csv"
const sp = getpolardata(filename)

@show haversine(1,1,1,2)

@show minimumtimeroute(routeprob, sp)
