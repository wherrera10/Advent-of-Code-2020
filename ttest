using LinearAlgebra

coords(d) = collect(Base.product([collect(1:x) for x in reverse(d)]...))

# Construct a row for each value in g to be sent to the simultaneous equation solver
function row(g, f, gcoord, hsize)
    retrow = similar(g, 0)
    gcoord = gcoord[(1:x for x in size(f))...]; # clip extraneous values
    for hc in coords(hsize)
        fcoord = similar(g, 0)
        for i in hc
            window = gcoord[i] - hc[i]
            if window < 0 || window >= size(f)[i]
                break
            end
            push!(fcoord, window)
        end
        push!(retrow, fcoord == hc ? f[fcoord] : 0)
    end
    append!(retrow, g[gcoord])
    retrow
end

function rref(m)
    s = size(m)
    x = view(m, 1:s[1], 1:s[2]-1) \ view(m, 1:s[1], s[2])
    n = length(x)
    ret, ident = fill(zero(m[1,1]), n, n + 1), one(m[1,1])
    for i in 1:n
        ret[i, i] = ident
    end
    ret[:, n + 1] .= x
    ret
end

function deconvolveN(g, f)
    gsize = size(g)
    hsize = gsize .- size(f) .+ 1
    idx = coords(gsize)
    tosolve = fill(zero(g[1]), gsize...)
    for i in 1:gsize[1], x in coords(gsize)
        tosolve[i, 1:end] .= row(g, f, x, hsize)
    end
    solved = rref(tosolve)
    h = similar(g, 0)
    for (c, v) in zip(coords(hsize), solved())
        h[c] = v
    end
    h
end








