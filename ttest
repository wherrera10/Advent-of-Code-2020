import Base.print, Base.sort!

abstract type Entry end

mutable struct OutlineEntry <: Entry
    level::Int
    text::String
    parent::Union{Entry, Nothing}
    children::Vector{Entry}
end

mutable struct Outline
    root::OutlineEntry
    entries::Vector{OutlineEntry}
    baseindent::String
end

rootentry() = OutlineEntry(0, "", nothing, [])
indentchar(ch) = ch == ' ' || ch == '\t'
firsttext(s) = something(findfirst(!indentchar, s), length(s) + 1)
splitline(s) = begin i = firsttext(s); i == 1 ? ("", s) : (s[1:i-1], s[i:end]) end

const _indents = ["        "]

function Base.print(io::IO, oe::OutlineEntry)
    println(io, _indents[end]^oe.level, oe.text)
    for child in oe.children
        print(io, child)
    end
end

function Base.print(io::IO, o::Outline)
    push!(_indents, o.baseindent)
    print(io, o.root)
    pop!(_indents)
end

function firstindent(lines, default = "        ")
    for lin in lines
        s1, s2 = splitline(lin)
        s1 != "" && return s1
    end
    return default
end

function Outline(str::String)
    arr, lines = OutlineEntry[], filter(x -> x != "", split(str, r"\r\n|\n|\r"))
    root, indent, parentindex, lastindents = rootentry(), firstindent(lines), 0, 0
    indentlen, indentregex = length(indent), Regex(indent)
    for (i, lin) in enumerate(lines)
        header, txt = splitline(lin)
        indentcount = length(collect(eachmatch(indentregex, header)))
        (indentcount * indentlen < length(header)) && throw("Error: bad indent <$header>")
        if indentcount > lastindents
            parentindex = i - 1
        elseif indentcount < lastindents
            parentindex = something(findlast(x -> x.level == indentcount - 1, arr), 0)
        end
        lastindents = indentcount
        ent = OutlineEntry(indentcount, txt, parentindex == 0 ? root : arr[parentindex], [])
        push!(ent.parent.children, ent)
        push!(arr, ent)
    end
    return Outline(root, arr, indent)
end

function sorttree!(ent::OutlineEntry, rev=false)
    for child in ent.children
        sorttree!(child, rev)
    end
    sort!(ent.children, lt=(x, y) -> x.text < y.text, rev=rev)
    return ent
end

sort!(o::Outline, rev=false) = begin sorttree!(o.root, rev); o end

const outl = Outline("""
This topic is topical at last.
    B.
        3.
        1.
        2.
        4.
    C.
        2.
        4.
        3.
        1.
    A.
Next part is off topic
    C.
    A.
    B.
First part""")

println("Unsorted")
println(outl)
println("sorted")
println(sort!(outl))
println(sort!(outl, true))
println(sort!(outl))
