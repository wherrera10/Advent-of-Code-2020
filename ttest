# black box

struct Position x::Int; y::Int; end

const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]

const rebound(d) = -1 .* d

const emptyboard = fill('?', 8, 8)

printboard(brd) = for row in eachrow(brd) for c in row print(c * " ") end; println() end

printboard(emptyboard)

println()

cart = CartesianIndices(emptyboard)

board = deepcopy(emptyboard)

board[rand(cart, 4)] .= '*'

printboard(board)


function diagonalright(position, direction) 
    if direction[1] == 1 # down
        return position .+ [1, -1]
    elseif direction[1] == -1 #up
        return position .+ [-1, 1]
    elseif direction[2] == -1 # left
        return position .+ [-1, -1]
    else
        return position .+ [1, 1]
    end
end

isvalidposition(p) = (1 <= p.y <= 8) && (1 <= p.x <= 8)

blocked(p, brd) = brd[p.x, p.y] == '*'

function reflected(position, direc, brd)
    newp = position .+ direc
    if d[1] == 1 || d[1] == -1
        return brd[newp.x, newp.y + 1] == '*' && 
               brd[newp.x, newp.y - 1] == '*'
    elseif d[2] == 1 || d[2] == -1
        return brd[newp.x, newp.y + 1] == '*' && 
               brd[newp.x, newp.y - 1] == '*'
    

function pathresult(start, direction, board)
    current = start
    while isvalidposition(current)
    
    for col in 1:8, row in 1:8
        if board[row, col] == '*'
            return "0" # nothing out
        end
        rightcorner, leftcorner = start .+ 
        elseif col > 1 && row < 8 && board[row + 1, col - 1] == '*'
            if col < 8 && board[row + 1, col + 1] == '*'
                return pathresult(current, rebound(direction), board)
            else
                
            end
        elseif


