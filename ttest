
const stepdirections = [[1, 0], [0, 1], [1, 1], [1, -1], [-1, 0], [0, -1], [-1, -1], [-1, 1]]
const nrows    = 10
const ncols    = nrows
const gridsize = nrows * ncols
const minwords = 25

mutable struct LetterGrid
    nattempts::Int
    nrows::Int
    ncols::Int
    cells::Matrix{Char}
    solutions::Vector{String}
    LetterGrid() = new(0, nrows, ncols, fill(' ', nrows, ncols), Vector{String}())
end

function wordmatrix(filename)
    words = [lowercase(line) for line in readlines(filename) if match(r"^[a-zA-Z]+$", line) != nothing]
    n = 100
    for i in 1:n
        grid = LetterGrid()
        messagelen = placemessage(grid, "Rosetta Code")
        target = grid.nrows * grid.ncols - messagelen
        cellsfilled = 0
        shuffle!(words)
        for word in words
            cellsfilled += tryplaceword(grid, word)
            if cellsfilled == target
                if length(grid.solutions) >= minwords
                    grid.nattempts = i
                    return grid
                else
                    break
                end
            end
        end
    end
    throw("Failed to place words after n attempts")
end

function placemessage(grid, msg)
    msg = uppercase(msg)
    msg = replace(msg, r"[^A-Z]" => "")
    messagelen = length(msg)
    if messagelen > 0 && messagelen < gridsize
        positions = Int.(floor.(LinRange(messagelen, gridsize, messagelen) .+
                     (rand(messagelen) .- 0.5) * messagelen / 3)) .- div(messagelen, 3)
        foreach(i -> grid.cells[positions[i]] = msg[i], 1:messagelen)
        return messagelen
    end
    return 0
end

function tryplaceword(grid, word)
    dlen = length(stepdirections)
    randdir = rand(1:dlen)
    randpos = rand(1:gridsize)
    for dir in 1:dlen
        dir = dir + randdir > dlen ? dir + randdir - dlen : dir + randdir
        for pos in 1:gridsize
            pos = pos + randpos > gridsize ? pos + randpos - gridsize : pos + randpos
            lettersplaced = trylocation(grid, word, dir, pos)
            if lettersplaced > 0
                return lettersplaced
            end
        end
    end
    return 0
end

function trylocation(grid, word, dir, pos)
    r, c = divrem(pos, ncols)
    len = length(word)
    if  (stepdirections[dir][1] == 1 && (len + c) > ncols) || 
        (stepdirections[dir][1] == -1 && (len - 1) > c) ||
        (stepdirections[dir][2] == 1 && (len + r) > nrows) ||
        (stepdirections[dir][2] == -1 && (len - 1) > r)
        return 0
    end
    overlaps = 0
    rr = r + 1
    if rr > nrows rr = nrows end
    cc = c + 1
    if cc > ncols cc = ncols end
    for i in 1:len-1
        if grid.cells[rr, cc] != 0 && grid.cells[rr, cc] != word[i]
            return 0
        end
        cc += stepdirections[dir][1]
        if cc > ncols cc = ncols end
        rr += stepdirections[dir][2]
        if rr > nrows rr = nrows end
    end
    rr = r + 1
    if rr > nrows rr = nrows end
    cc = c + 1
    if cc > ncols cc = ncols end
    for i in 1:len
        if grid.cells[rr, cc] == word[i]
            overlaps += 1
        else
            grid.cells[rr, cc] = word[i]
        end
        if i < len - 1
            cc += stepdirections[dir][1]
            rr += stepdirections[dir][2]
        end
    end

    lettersplaced = len - overlaps
    if lettersplaced > 0
        push!(grid.solutions, lpad(word, 10) * " ($c, $r)($cc,$rr)")
    end
    return lettersplaced
end

function printresult(grid)
    if grid.nattempts == 0
        println("No grid to display: no solution found.")
        return
    end
    size = length(grid.solutions)
    println("Attempts: ", grid.nattempts)
    println("Number of words: ", size)
    println("\n     0  1  2  3  4  5  6  7  8  9")
    for r in 1:nrows
        print("\n$r   ")
        for c in 1:ncols
            print(" $(grid.cells[r, c]) ")
        end
    end
    println()
    for i in 1:2:size
        println("$(grid.solutions[i])   $(i < size ? grid.solutions[i+1] : "")")
    end
end

printresult(wordmatrix("words.txt"))

