
struct Sphere
   centerX::Int
   centerY::Int
   centerZ::Int
   radius::Int
end

const colordepth = 255
const pgmsize = 255
const scale = 127
const lighting = normalize([4, -1, 3])
const possphere = Sphere(120, 120, 0, 120)
const negsphere = Sphere(-77, -33, -100, 190)

function withinsphere(sphere, x, y)
    x -= sphere.centerX
    y -= sphere.centerY
    z2 = sphere.radius^2 - x^2 - y^2
    if z2 < 0
        return false, 0.0, 0.0
    end
    zret = sqrt(z2)
    true, sphere.centerZ - zret, sphere.centerZ + zret
end

function drawdeathstar(k, ambient)
    pixels = zeros(Int, pgmsize * pgmsize)
    for y in possphere.centerY - possphere.radius:possphere.centerY + possphere.radius
        row = zeros(Int, pgmsize*2)
        for x in (possphere.centerX - possphere.radius):(possphere.centerX + possphere.radius)
            (inpos, poszlo, poszhi) = withinsphere(possphere, x, y)
            if !inpos
                row[x + scale + 1] = 0
                continue
            end
            vec = Vector{Int}()
            (inneg, negzlo, negzhi) =  withinsphere(negsphere, x, y)
            if inneg && negzlo < poszlo < negzhi # located in lens cutout
                if negzlo < poszhi < negzhi
                    row[x + scale + 1] = 0
                    continue
                end
                vec = normalize([negsphere.centerX - x, negsphere.centerY - y, -negzhi - negsphere.centerZ])
            else
                vec = normalize([x - possphere.centerX, y - possphere.centerY, poszhi - possphere.centerZ])
            end
            intensity = dot(lighting, vec)^k + ambient
            row[x + scale] = Int(ceil(min((intensity * colordepth) , colordepth)))
        end
        pixels[y + scale + 1:y + scale + 240] .= row[1:240]
    end
    pixels[:]
end

f = open("deathstar.pgm", "w")
write(f, "P5\n$scale $scale\n$colordepth\n")
write(f, drawdeathstar(3, 0.15))
