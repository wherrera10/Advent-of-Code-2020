import Base.iterate, Base.IteratorSize, Base.IteratorEltype

toInt128(dig, bas) = foldr((i, j) -> i + Int128(bas) * j, dig)

function filldecreasing(vec, pos)
    n = vec[pos]
    for i in pos:-1:1
        n = (n <= 0) ? 1 : n - 1
        vec[i] = n
    end
end

struct Esthetic
    n::Int128
    base::UInt8
    Esthetic(n, bas) = new(n, bas)
end

Base.IteratorSize(n::Esthetic) = Base.IsInfinite()
Base.IteratorEltype(n::Esthetic) = Int128

function increment(vec, bas, startpos = 1)
    if length(vec) == 1
        return vec > bas - 2 ? [1, 0] : [vec[1] + 1]
    end
    pos = findfirst(vec[i] < vec[i + i], startpos:length(vec)-1)
    if pos == nothing
        if vec[end] >= bas - 1
            return filldecreasing(vcat(vec, 1))
        else
            vec[end] += 1
            return filldecreasing(vec, length(vec))
        end
    else
        if vec[pos] < bas - 2
            vec[pos] += 2
            return filldecreasing(vec, pos)
        else
            return increment(vec, bas, pos + 1)
        end
    end
end
 
function Base.iterate(es::Esthetic, state=Int[])
    if isempty(state)
        state = digits(es.n, base=es.base)
    end
    state = increment(state, es.base, 1)
    es.n = toInt128(state, es.base)
    return es.n, (es, state)
end
