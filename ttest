import Main.isapprox

const radius = 1.0   # simplifies calculations
const θ = π / 6      # 30 degrees

struct Point
	x::Float32
	y::Float32
end

Main.isapprox(p1::Point, p2::Point) = isapprox(p1.x, p2.x) && isapprox(p1.y, p2.y)

rightwardfrom(start, angle) = Point(start.x + sin(angle + θ), start.y + cos(angle + θ))
leftwardfrom(start, angle) = Point(start.x + sin(angle - θ), start.y + cos(angle - θ))

struct RailwayCircuit
    startpoint::Point
    startdirection::Float64
    turns::Array{Bool, 1}  # true for right, false for left
    RailwayCircuit(turnarray=Bool[]) = new(Point(0, 0), 0, turnarray)
end

function issymmetry(c1, c2)
    return length(c1) == length(c2) && sum(c1) == sum(c2) &&
        any(n -> c1 == circshift(c2, n), 0:length(c2)-1)
end

isduplicate(c1, c2) = issymmetry(c1, c2) || issymmetry(c1, [!x for x in c2])

function points(tracks::RailwayCircuit)
    ret, point, ϕ = [tracks.startpoint], tracks.startpoint, tracks.startdirection
    for turn in tracks.turns
		if turn
			point = rightwardfrom(point, ϕ)
			ϕ += θ
		else
		    point = leftwardfrom(point, ϕ)
		    ϕ -= θ
		end
		push!(ret, point)
    end
    return ret
end

isvalidcircuit(tracks) = (c = points(tracks); c[1] ≈ c[end])

function allvalidcircuits(N)
	ret = RailwayCircuit[]
	for i in 0:2^N-1
		c = RailwayCircuit([d -> d == 1 for d in digits(i, base=2)])
		if isvalidcircuit(c) & all(x -> !isduplicate(x.turns, c.turns), ret)
			push!(ret, c)
		end
	end
	ret			
end
