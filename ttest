using LinearAlgebra

shape(a) = ((x, r) = (a, Int[]); while x isa Array push!(r, length(x)); x = x[1] end; r)
coords(d) = reshape(collect(Base.product([collect(1:x) for x in reverse(d)]...)), prod(d))

# Construct a row for each value in g to be sent to the simultaneous equation solver
function row(g, f, hsize, gcoord)
    retrow = similar(g, 0)
println("gcoord $gcoord")
    gcoord = gcoord[(1:x for x in shape(f))...]; # clip extraneous values
    for hc in coords(hsize)
        fcoord = similar(g, 0)
        for i in 1:length(hc)
            window = gcoord[i] .- hc[i]
            if window[1] < 0 || window[1] >= shape(f)[i]
                break
            end
            push!(fcoord, window[1])
        end
        push!(retrow, fcoord .== hc ? f[fcoord] : 0)
    end
    append!(retrow, g[gcoord])
    retrow
end

function rref(m)
    if length(m) == 0
        return m
    end
    s = shape(m)
    x = view(m, 1:s[1], 1:s[2]-1) \ view(m, 1:s[1], s[2])
    n = length(x)
    ret, ident = fill(zero(m[1,1]), n, n + 1), one(m[1,1])
    for i in 1:n
        ret[i, i] = ident
    end
    ret[:, n + 1] .= x
    ret
end

function deconvolveN(g, f)
    gsize = shape(g)
    hsize = gsize .- shape(f) .+ 1
    tosolve = map(x -> [row(g, f, hsize, x)], coords(gsize))
    solved = rref(tosolve)
    h = similar(g, length(solved()))
    for (c, v) in zip(coords(hsize), solved())
        h[c] = v
    end
    h
end

const h =  [-8, 2, -9, -2, 9, -8, -2]
const f = [ 6, -9, -7, -5]
const g = [-48, 84, -16, 95, 125, -70, 7, 29, 54, 10]

println(deconvolveN(g, f))

