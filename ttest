
module Hidato

export hidatosolve, printboard, hidatoconfigure

function hidatoconfigure(str)
    lines = split(str, "\n")
    nrows, ncols = length(lines), length(split(lines[1], r"\s+"))
    board = fill(-1, (nrows, ncols))
    presets = Vector{Int}()
    starts = Vector{CartesianIndex{2}}()
    maxmoves = 0
    for (i, line) in enumerate(lines), (j, s) in enumerate(split(strip(line), r"\s+"))
        c = s[1]
        if c == '_' || (c == '0' && length(s) == 1)
            board[i, j] = 0
            maxmoves += 1
        elseif c == '.'
            continue
        else # numeral, get 2 digits
            board[i, j] = parse(Int, s)
            push!(presets, board[i, j])
            if board[i, j] == 1
                push!(starts, CartesianIndex(i, j))
            end
            maxmoves += 1
        end
    end
    board, maxmoves, sort!(presets), length(starts) == 1 ? starts : findall(x -> x == 0, board)
end

function hidatosolve(board, maxmoves, movematrix, fixed, row, col, sought, next)
    if sought > maxmoves
        return true
    elseif (0 != board[row, col] != sought) || (board[row, col] == 0 && sought in fixed)
        return false
    end
    backnum = 0
    if board[row, col] == sought
        backnum = sought
        next += 1
    end
    board[row, col] = sought # try board with this cell set to next number
    for move in movematrix
        i, j = row + move[1], col + move[2]
        if (0 < i <= size(board)[1]) && (0 < j <= size(board)[2]) &&
            hidatosolve(board, maxmoves, movematrix, fixed, i, j, sought + 1, next)
            return true
        end
    end
    board[row, col] = backnum # return board to original state
    false
end

function printboard(board, emptysquare= "__ ", blocked = "   ")
    d = Dict(-1 => blocked, 0 => emptysquare, -2 => "\n")
    map(x -> d[x] = rpad(lpad(string(x), 2), 3), 1:maximum(board))
    println(join([d[i] for i in hcat(board, fill(-2, size(board)[1]))'], ""))
end

end  # module

using .Hidato

hidat = """
__ 33 35 __ __  .  .  .
__ __ 24 22 __  .  .  .
__ __ __ 21 __ __  .  .
__ 26 __ 13 40 11  .  .
27 __ __ __  9 __  1  .
 .  . __ __ 18 __ __  .
 .  .  .  . __  7 __ __
 .  .  .  .  .  .  5 __"""

const kingmoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]

board, maxmoves, fixed, starts = hidatoconfigure(hidat)
printboard(board)
hidatosolve(board, maxmoves, kingmoves, fixed, starts[1][1], starts[1][2], 1, 1)
printboard(board)

const hopid = """
 . 0 0 . 0 0 .
 0 0 0 0 0 0 0
 0 0 0 0 0 0 0
 . 0 0 0 0 0 .
 . . 0 0 0 . .
 . . . 0 . . . """

const hopidomoves = [[-3, 0], [0, -3], [-2, -2], [-2, 2], [2, -2], [0, 3], [3, 0], [2, 2]]

board, maxmoves, fixed, starts = hidatoconfigure(hopid)
printboard(board, " 0", "  ")
hidatosolve(board, maxmoves, hopidomoves, fixed, starts[1][1], starts[1][2], 1, 1)
printboard(board)

const chessboard = """
 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 """

const knightmoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]

board, maxmoves, fixed, starts = hidatoconfigure(chessboard)
printboard(board, " 0", "  ")
hidatosolve(board, maxmoves, knightmoves, fixed, starts[1][1], starts[1][2], 1, 1)
printboard(board)

const holyknight = """
 . 0 0 0 . . . .
 . 0 . 0 0 . . .
 . 0 0 0 0 0 0 0
 0 0 0 . . 0 . 0
 0 . 0 . . 0 0 0
 1 0 0 0 0 0 0 .
 . . 0 0 . 0 . .
 . . . 0 0 0 . . """

const knightmoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]

board, maxmoves, fixed, starts = hidatoconfigure(holyknight)
printboard(board, " 0", "  ")
hidatosolve(board, maxmoves, knightmoves, fixed, starts[1][1], starts[1][2], 1, 1)
printboard(board)


