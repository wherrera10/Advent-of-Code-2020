mutable struct SharedIndex
    n::Int
    SharedIndex(ending=-1) = new(ending)
end

abstract struct Nod end

struct NilNode <: Nod end
const NILNODE = NilNode()
 
mutable struct Node
    children::Vector{Nod}
    suffixlink::Union{Nod, Nothing}
    start::Int
    ending::SharedIndex
    suffixindex::Int
    Node() = new([], nothing, -1, SharedIndex(), -1)
end

mutable struct SuffixTree
    text::String
    root::Union{Nod, Nothing}
    lastnewnode::Union{Nod, Nothing}
    activenode::Union{Nod, Nothing}
    activeedge::Int
    activelength::Int
    remainingsuffixcount::Int
    leafend::Int
    rootend::SharedIndex
    splitend::SharedIndex
    size::Int
    maxchar::Int
    SuffixTree() = new("", nothing, nothing, nothing, -1, -1, -1, -1, SharedIndex(), SharedIndex(), 0, 128)
end

function Suffixtree(text, maxchar=128)
    st = SuffixTree()
    st.text = text
    st.size = length(text)
    st.maxchar = maxchar
    root = Node(-1, st.rootend)
    st.activenode = st.root
    for i in 0:size-1
        extendsuffixtree(st, i)
    end
    labelheight = 0
    setsuffixindexbyDFS(root, labelheight)
    return st
end

Node(st::SuffixTree, start::Int, ending::ChainEnd) = Node([node() for _ in 1:st.maxchar], st.root, start, ending, -1)
edgelength(st, n) = (n == st.root) ? 0 : n.ending.n - n.start + 1
 
function walkdown(st, currnode)
    st.activelength < edgelength(currnode) && return false
    st.activeedge += edgelength(currnode)
    st.activelength -= edgelength(currnode)
    st.activenode = currnode
    return true
end

function extendsuffixtree(st, pos)
    st.leafend = pos
    st.remainingsuffixcount += 1
    st.lastnewnode = nothing
    while st.remainingsuffixcount > 0
        if st.activelength == 0
            st.activeedge = pos
        end
        if st.activenode.children[Int(st.text[st.activeedge]) + 1] == nothing
            st.activenode.children[Int(st.text[st.activeedge]) + 1] = Node(pos, SharedIndex(st.leafend))
            if st.lastnewnode != nothing
                st.lastnewnode.suffixlink = st.activenode
                st.lastnewnode = nothing
            end
        else
            next = st.activenode.children[Int(st.text[st.activeedge]) + 1]
            walkdown(st, next) && continue
            if st.text[next.start + st.activelength + 1] == st.text[pos + 1]
                if st.lastnewnode != nothing && st.activenode != root
                    st.lastnewnode.suffixlink = st.activenode
                    st.lastnewnode = nothing
                end
                st.activelength += 1
                break
            end
            temp = next.start + st.activelength - 1
            st.splitend = SharedIndex(temp)
            split = Node(next.start, st.splitend)
            st.activenode.children[st.text[st.activeedge + 1] + 1] = split
            split.children[st.text[pos + 1]] = Node(pos, SharedIndex(st.leafend))
            next.start += st.activelength
            split.children[st.text[next.start + 1] + 1] = next
            if st.lastnewnode != nothing
                st.lastnewnode.suffixlink = split
            end
            st.lastnnewnode = split
        end
        st.remainingsuffixcount -= 1
        if st.activenode == root && st.activelength > 0
            st.activelength -= 1
            st.activeedge = pos - remainingsuffixcount + 1
        elseif st.activenode != root
            st.activenode = st.activenode.suffixlink
        end
    end
end

function setsuffixindexbyDFS(st, n, labelheight, verbose=false)
    n == nothing && return
    verbose && n.start != -1 && print(st.text[n.start+1:n.ending.n+2])
    leaf = 1
    for i in 1:st.maxchar
        if n.children[i] != nothing
            verbose && leaf == 1 && n.start != -1 && println(" [$(n.suffixindex)]")
            leaf = 0
            setsuffixindexbyDFS(n.children[i], labelheight + st.edgelength(n.children[i]))
        end
    end
    if leaf == 1
        n.suffixindex = st.size - labelheight
        verbose && println(" [$(n.suffixindex)]")
    end
end
 
function traversal(st, n, labelheight, maxheight::SharedIndex, substringstartindex::SharedIndex)
    n == nothing && return
    if n.suffixindex == -1
        for i in 1:st.maxchar
            if n.children[i] != nothing
                traversal(n.children[i], labelheight + edgelength(n.children[i]),
                    maxheight, substringstartindex)
            end
        end
    elseif n.suffixindex > -1 && (maxheight.n < labelheight - edgelength(n))
        maxheight.n = labelheight - edgelength(n)
        substringstartindex.n = n.suffixindex
    end
end

function getlongestrepeatedsubstring(st, s::String)
    maxheight = SharedIndex(0)
    substringstartindex = SharedIndex(0)
    traversal(st, root, 0, maxheight, substringstartindex)
    // Uncomment line below to print maxHeight and substringStartIndex
    // fmt.Printf("maxHeight %d, substringStartIndex %d\n", maxHeight, substringStartIndex)
    if s == "" {
        fmt.Printf("  %s is: ", text)
    } else {
        fmt.Printf("  %s is: ", s)
    }
    k := 0
    for ; k < maxHeight; k++ {
        fmt.Printf("%c", text[k+substringStartIndex])
    }
    if k == 0 {
        fmt.Print("No repeated substring")
    }
    fmt.Println()
}
 
func calculatePi() *big.Float {
    one := big.NewFloat(1)
    two := big.NewFloat(2)
    four := big.NewFloat(4)
    prec := uint(325 * 1024) // enough to calculate Pi to 100,182 decimal digits
 
    a := big.NewFloat(1).SetPrec(prec)
    g := new(big.Float).SetPrec(prec)
 
    // temporary variables
    t := new(big.Float).SetPrec(prec)
    u := new(big.Float).SetPrec(prec)
 
    g.Quo(a, t.Sqrt(two))
    sum := new(big.Float)
    pow := big.NewFloat(2)
 
    for a.Cmp(g) != 0 {
        t.Add(a, g)
        t.Quo(t, two)
        g.Sqrt(u.Mul(a, g))
        a.Set(t)
        pow.Mul(pow, two)
        t.Sub(t.Mul(a, a), u.Mul(g, g))
        sum.Add(sum, t.Mul(t, pow))
    }
 
    t.Mul(a, a)
    t.Mul(t, four)
    pi := t.Quo(t, u.Sub(one, sum))
    return pi
}
 
func main() {
    tests := []string{
        "GEEKSFORGEEKS$",
        "AAAAAAAAAA$",
        "ABCDEFG$",
        "ABABABA$",
        "ATCGATCGA$",
        "banana$",
        "abcpqrabpqpq$",
        "pqrpqpqabab$",
    }
    fmt.Println("Longest Repeated Substring in:\n")
    for _, test := range tests {
        text = test
        buildSuffixTree()
        getLongestRepeatedSubstring("")
    }
    fmt.Println()
 
    pi := calculatePi()
    piStr := fmt.Sprintf("%v", pi)
    piStr = piStr[2:] // remove initial 3.
    numbers := []int{1e3, 1e4, 1e5}
    maxChar = 58
    for _, number := range numbers {
        start := time.Now()
        text = piStr[0:number] + "$"
        buildSuffixTree()
        getLongestRepeatedSubstring(fmt.Sprintf("first %d d.p. of Pi", number))
        elapsed := time.Now().Sub(start)
        fmt.Printf("  (this took %s)\n\n", elapsed)
    }
}


